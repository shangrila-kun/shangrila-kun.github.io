<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Shangrila-kun Blog</title>
  
  <subtitle>Full of passion to meet every day</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shangrila-kun.github.io/"/>
  <updated>2018-05-04T00:48:20.082Z</updated>
  <id>https://shangrila-kun.github.io/</id>
  
  <author>
    <name>Shangrila-kun</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象2</title>
    <link href="https://shangrila-kun.github.io/2018/05/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A12/"/>
    <id>https://shangrila-kun.github.io/2018/05/04/面向对象2/</id>
    <published>2018-05-04T00:46:41.000Z</published>
    <updated>2018-05-04T00:48:20.082Z</updated>
    
    <content type="html"><![CDATA[<p>​    本章主要介绍继承、super、从写 、instanceof、final关键子。</p><a id="more"></a><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote><p>继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。</p><p>继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。</p><p>1：学生   是人  </p><p>​    2：狗     是动物</p><p>​    3：球队 包含 球员 整体与部分的关系，部分可以删除和增加</p><p>​    4：笔记本包含 cpu 整体与部分的关系，部分不可以删除和增加</p><p>​    5：航母编队 包含（航母 护卫舰 驱逐舰 舰载机 核潜艇）</p><p>1：如果没有继承,出现类和类的关系无法描述</p><p>2：如果没有继承，类和类之间有关系会出现类和类的描述代码的重复</p></blockquote><h3 id="继承特点好坏处"><a href="#继承特点好坏处" class="headerlink" title="继承特点好坏处"></a>继承特点好坏处</h3><blockquote><p>1：描述类和类之间的关系</p><p>2：降低类和类之间的重复代码</p><p>1：降低对象和对象之间的代码重复使用静态变量</p><p>2：降低类和类之间的代码重复使用继承</p></blockquote><p><strong>好处</strong></p><blockquote><ol><li>提高了代码的复用性</li><li>简化了代码的维护工作</li><li>是构造多态的基础</li></ol></blockquote><p><strong>坏处</strong></p><blockquote><ol><li>不符合低耦合高内聚的思想，让类与类的关系更紧密，类与类的关系复杂</li><li>打破了封装性<br>封装的好处在只能从类暴露的方法去访问私有变量，但是继承则可以从子类方法通过继承的父类方法间接去访问父类的私有成员。<br>另外，如果要想让子类继承共性的属性（成员变量），则不能进行封装，因为private的成员变量和方法都不能被继承，这构成了冲突。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; 继承细节；</div><div class="line">&gt; 1：类名的设定，被继承的类称之为父类(基类)，继承的类称之为子类</div><div class="line">&gt; 2：子类并不能继承父类中所有的成员</div><div class="line">&gt; 1：父类定义完整的成员 静态成员，非静态，构造方法。静态变量和静态方</div><div class="line">&gt; 法都可以通过子类名.父类静态成员的形式调用成功。</div><div class="line">&gt; 2：所有的私有成员不能继承,private修饰的成员。</div><div class="line">&gt; 3：构造函数不能被继承</div><div class="line">&gt;</div><div class="line">&gt; 3：如何使用继承</div><div class="line">&gt; 1：不要为了使用继承而继承。工人和学生都有共性的成员，不要为了节省代</div><div class="line">&gt; 码，让工人继承学生。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="继承的使用场景"><a href="#继承的使用场景" class="headerlink" title="继承的使用场景"></a>继承的使用场景</h3><blockquote><p>存在“is a”的关系时，例如猫is a 动物，狗is a 动物。</p></blockquote><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line">&gt;</div><div class="line">&gt; Father() &#123;</div><div class="line">&gt; System.out.println(<span class="string">"这是父类无参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; Father(<span class="keyword">int</span> x) &#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="keyword">this</span>.x = x;</div><div class="line">&gt; System.out.println(<span class="string">"这是父类有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"我是父亲"</span>);</div><div class="line">&gt; &#125;                  </div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">int</span> y = <span class="number">1</span>;</div><div class="line">&gt;</div><div class="line">&gt; Son() &#123;</div><div class="line">&gt; System.out.println(<span class="string">"这是子类的无参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; Son(<span class="keyword">int</span> y) &#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="keyword">this</span>.y = y + x;</div><div class="line">&gt; System.out.println(<span class="string">"这是子类的有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">super</span>.speak(); <span class="comment">// 访问父类的函数</span></div><div class="line">&gt; System.out.println(<span class="string">"我是儿子"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; Son s = <span class="keyword">new</span> Son(<span class="number">3</span>);</div><div class="line">&gt; System.out.println(s.y);<span class="comment">// 4</span></div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>子类对象为什么可以访问父类的成员。</p><p>​    1：this.y=y+x;有一个隐式的super super.x</p></blockquote><h3 id="super关键字的作用"><a href="#super关键字的作用" class="headerlink" title="super关键字的作用"></a>super关键字的作用</h3><blockquote><p>super关键字作用</p><p>​    1：主要存在于子类方法中，用于指向子类对象中父类对象。</p><p>​    2：访问父类的属性</p><p>​    3：访问父类的函数</p><p>​    4：访问父类的构造函数</p></blockquote><h3 id="super注意事项"><a href="#super注意事项" class="headerlink" title="super注意事项"></a>super注意事项</h3><blockquote><p>this和super很像，this指向的是当前对象的调用，super指向的是当前调用对象的父类。Demo类被加载，执行main方法，Son.class加载，发现有父类Father类，于是Father类也加载进内存。类加载完毕，创建对象，父类的构造方法会被调用（默认自动无参），然后执行子类相应构造创建了一个子类对象，该子类对象还包含了一个父类对象。该父类对象在子类对象内部。this super只能在有对象的前提下使用，不能在静态上下文使用。</p><p>子类的构造函数默认第一行会默认调用父类无参的构造函数，隐式语句super();</p><p>1：父类无参构造函数不存在，编译报错。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; Son(<span class="keyword">int</span> y) &#123;</div><div class="line">&gt; <span class="comment">//super();隐式语句</span></div><div class="line">&gt; <span class="keyword">this</span>.y = y + x;</div><div class="line">&gt; System.out.println(<span class="string">"这是子类的有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>在子类构造函数第一行通过super关键字调用父类任何构造函数。如果显式调用父类构造函数，编译器自动添加的调用父类无参数的构造就消失。构造函数间的调用只能放在第一行，只能调用一次。super() 和this()不能同时存在构造函数第一行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&gt; Son(<span class="keyword">int</span> y) &#123;</div><div class="line">&gt; <span class="keyword">super</span>(y);<span class="comment">// 子类显式调用父类构造函数</span></div><div class="line">&gt; <span class="keyword">this</span>.y = y + x;</div><div class="line">&gt; System.out.println(<span class="string">"这是子类的有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; Son(<span class="keyword">int</span> y) &#123;</div><div class="line">&gt; <span class="keyword">this</span>();  <span class="comment">//不能同时存在构造函数第一行  </span></div><div class="line">&gt; <span class="keyword">super</span>(y);</div><div class="line">&gt; <span class="keyword">this</span>.y = y + x;</div><div class="line">&gt; System.out.println(<span class="string">"这是子类的有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h2 id="重写（Override）"><a href="#重写（Override）" class="headerlink" title="重写（Override）"></a>重写（Override）</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; 定义Father类</div><div class="line">&gt; 1：姓名，吃饭方法，吃窝窝头。</div><div class="line">&gt; 2：定义Son类，继承Father</div><div class="line">&gt; 1：Son类中不定义任何成员，子类创建对象，仍然可以调用吃饭的方法。</div><div class="line">&gt; 2：父类的吃饭的方法，Son不愿吃。Son自己定义了吃饭的方法。</div><div class="line">&gt; 1：此时父类中有一个吃饭的方法，子类中有2个吃饭的方法，一模一样，只是方法体不一样。</div><div class="line">&gt; 2：一个类中两个函数一模一样，是不允许的。</div><div class="line">&gt; 1：编译运行，执行了子类的方法。</div><div class="line">&gt; 2：使用父类的方法，在子类方法中，使用super.父类方法名。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃窝窝"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">// 继承可以使得子类增强父类的方法</span></div><div class="line">&gt; System.out.println(<span class="string">"来俩小菜"</span>);</div><div class="line">&gt; System.out.println(<span class="string">"来两杯"</span>);</div><div class="line">&gt; System.out.println(<span class="string">"吃香喝辣"</span>);</div><div class="line">&gt; System.out.println(<span class="string">"来一根"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; Son s = <span class="keyword">new</span> Son();</div><div class="line">&gt;         <span class="comment">//执行子类的方法</span></div><div class="line">&gt; s.eat();</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>3：该现象就叫做重写(覆盖 override)</p><p>1： 在继承中，子类可以定义和父类相同的名称且参数列表一致的函数，将这种函数</p><p>称之为函数的重写.</p><p>4：前提</p><p>​    1：必须要有继承关系</p><p>5：特点</p><p>1：当子类重写了父类的函数，那么子类的对象如果调用该函数，一定调用的是重写过后的函数。</p><p>​       可以通过super关键字进行父类的重写函数的调用。</p><p>​    2： 继承可以使得子类增强父类的方法</p><p>6：细节</p><p>​    1： 函数名必须相同</p><p>​    2：参数列表必须相同</p><p>3： 子类重写父类的函数的时候，函数的访问权限必须大于等于父类的函数的访</p><p>问权限否则编译报错</p><p>4：子类重写父类的函数的时候，返回值类型必须是父类函数的返回值类型或该返回值类型的子类。不能返回比父类更大的数据类型： 如子类函数返回值类型是Object</p><p>​        1：定义 A B  C 类 B extends A  </p><p>​        2：Father类中定义A getA();</p><p>​        3：Son 类中重写getA(); 方法，尝试将返回值修改为B，C ,Object</p><p>​            1：B编译通过</p><p>​            2：C 编译失败 ,没有继承关系</p><p>​            3：Object编译失败,比父类的返回值类型更大</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃窝窝"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">// 定义一个函数，获取A类的对象，</span></div><div class="line">&gt; <span class="function">A <span class="title">getA</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> <span class="keyword">new</span> A();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123; <span class="comment">// 继承可以使得子类增强父类的方法</span></div><div class="line">&gt; System.out.println(<span class="string">"来两杯"</span>);</div><div class="line">&gt; System.out.println(<span class="string">"来俩小菜"</span>);</div><div class="line">&gt; <span class="keyword">super</span>.eat();</div><div class="line">&gt; System.out.println(<span class="string">"来一根"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">// B类是A类的子类</span></div><div class="line">&gt; <span class="function">B <span class="title">getA</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> <span class="keyword">new</span> B();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo8</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; Son s = <span class="keyword">new</span> Son();</div><div class="line">&gt; s.eat();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>7：子类对象查找属性或方法时的顺序：</p><p>​    1：原则：就近原则。</p><p>如果子类的对象调用方法，默认先使用this进行查找，如果当前对象没有找到属性或方法，找当前对象中维护的super关键字指向的对象，如果还没有找到编译报错，找到直接调用。</p><p>8：重载和重写的不同</p><p>​    1：重载(overload)：  </p><p>​        1：前提： 所有的重载函数必须在同一个类中 </p><p>​        2：特点： </p><p>​               函数名相同，参数列表不同，与其他的无关(访问控制符、返回值类型)</p><p>​        3：不同：</p><p>​            个数不同 、 顺序不同、 类型不同 </p><p>​    2：重写(override)：</p><p>​         1：前提： 继承</p><p>​        2：特点：</p><p>​              函数名必须相同、参数列表必须相同。</p><p>​              子类的返回值类型要等于或者小于父类的返回值</p><p>9：重写练习</p><p>​        描述不同的动物不同的叫法</p><p>​        1：定义动物类</p><p>​            有名字，有吃和叫的方法</p><p>​        2：定义狗继承动物重写父类吃和叫的方法</p><p>​        3：定义猫继承动物重写父类吃和叫的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&gt; <span class="keyword">int</span> x=<span class="number">1</span>;</div><div class="line">&gt; String name;</div><div class="line">&gt; </div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃东西"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"我是动物"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&gt; </div><div class="line">&gt; </div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"啃骨头"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"旺旺"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃："</span>+food);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span></span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃老鼠"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"喵喵"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo9</span></span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">&gt; Dog d=<span class="keyword">new</span> Dog();</div><div class="line">&gt; d.shout();</div><div class="line">&gt; d.eat();</div><div class="line">&gt; </div><div class="line">&gt; Cat c=<span class="keyword">new</span> Cat();</div><div class="line">&gt; c.shout();</div><div class="line">&gt; c.eat();</div><div class="line">&gt; System.out.println();</div><div class="line">&gt;      &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="instanceof关键字"><a href="#instanceof关键字" class="headerlink" title="instanceof关键字"></a>instanceof关键字</h2><blockquote><p>1：快速演示instanceof </p><p>​    2：instanceof是什么？</p><p>​        1：属于比较运算符：</p><pre><code>2：instanceof关键字：该关键字用来判断一个对象是否是指定类的对象。3：用法：</code></pre><p>​                  对象  instanceof 类;   </p><p>​          该表达式是一个比较运算符，返回的结果是boolea类型  true|false</p><p>​    注意：使用instanceof关键字做判断时，两个类之间必须有关系。</p><p>3：案例</p><p>定义一个功能表函数，根据传递进来的对象的做不同的事情，如果是狗让其看家，如果是猫让其抓老鼠</p><p>​        1：定义动物类</p><p>​        2：定义狗类继承动物类</p><p>​        3：定义猫类继承动物类</p><p>​        4：定义功能根据传入的动物，执行具体的功能</p><p>​        5：instanceof好处</p><p>​            1：可以判断对象是否是某一个类的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">package</span> oop01;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">/*</span></div><div class="line">&gt;  instanceof</div><div class="line">&gt;  比较运算符</div><div class="line">&gt;  检查是否是类的对象</div><div class="line">&gt;  1：可以判断对象是否是某一个类的实例</div><div class="line">&gt;  用法</div><div class="line">&gt;  对象  instanceof 类; </div><div class="line">&gt;  </div><div class="line">&gt;  案例</div><div class="line">&gt; 定义一个功能函数，根据传递进来的对象的做不同的事情</div><div class="line">&gt; 如果是狗让其看家，如果是猫让其抓老鼠</div><div class="line">&gt; 1：定义动物类</div><div class="line">&gt; 2：定义狗类继承动物类</div><div class="line">&gt; 3：定义猫类继承动物类</div><div class="line">&gt; 4：定义功能根据传入的动物，执行具体的功能</div><div class="line">&gt;  */</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; String name;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃东西"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"我是动物"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"啃骨头"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"旺旺"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"吃老鼠"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"喵喵"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo11</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; Demo11 d = <span class="keyword">new</span> Demo11();</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// 对象 instanceof 类;</span></div><div class="line">&gt; System.out.println(d <span class="keyword">instanceof</span> Demo11);</div><div class="line">&gt;</div><div class="line">&gt;  d.doSomething(<span class="keyword">new</span> Dog());</div><div class="line">&gt; d.doSomething(<span class="keyword">new</span> Cat());</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// 定义一个功能函数，根据传递进来的对象的做不同的事情</span></div><div class="line">&gt; <span class="comment">// 如果是狗让其看家，如果是猫让其抓老鼠</span></div><div class="line">&gt; <span class="comment">// 对象 instanceof 类;</span></div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Animal a)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog) &#123;</div><div class="line">&gt; a.eat();</div><div class="line">&gt; a.shout();</div><div class="line">&gt; System.out.println(<span class="string">"小狗看家"</span>);</div><div class="line">&gt; &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat) &#123;</div><div class="line">&gt; a.eat();</div><div class="line">&gt; a.shout();</div><div class="line">&gt; System.out.println(<span class="string">"抓老鼠"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; 练习:</div><div class="line">&gt; <span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">&gt; <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</div><div class="line">&gt; String[] ss = <span class="keyword">new</span> String[] &#123; <span class="string">"jack"</span>, <span class="string">"lucy"</span>, <span class="string">"lili"</span> &#125;;</div><div class="line">&gt; System.out.println(bs <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]); <span class="comment">// true</span></div><div class="line">&gt; System.out.println(is <span class="keyword">instanceof</span> <span class="keyword">int</span>[]); <span class="comment">// true</span></div><div class="line">&gt; System.out.println(ss <span class="keyword">instanceof</span> String[]); <span class="comment">// true</span></div><div class="line">&gt; <span class="comment">// System.out.println(bs instanceof int[]); // 不可转换的类型</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h2 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h2><blockquote><p>1：定义静态方法求圆的面积</p><p>​    2：定义静态方法求圆的周长</p><p>​    3：发现方法中有重复的代码，就是PI，圆周率。</p><p>​        1：如果需要提高计算精度，就需要修改每个方法中圆周率。</p><p>​    4：描述一个变量</p><p>​        1：方法都是静态的，静态只能访问静态，所以变量也定义为静态的。</p><p>public static double PI=3.14;</p><p>​            1：如果定义为public后，新的问题，类名.PI=300; 改变了PI的值。</p><p>2：修改为private，修改为private后进行了封装，需要getset公共访问方法。</p><p>​            3：现有的知识不能解决这样的问题了。可以使用final</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo12</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>; <span class="comment">// 静态常量</span></div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getArea</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> PI * r * r;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">getLength</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> PI * r * <span class="number">2</span>;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// Demo12.PI=300; 无法为最终变量 PI 指定值</span></div><div class="line">&gt; System.out.println(Demo12.PI);</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>5：使用final</p><p>​        1：final关键字主要用于修饰类、类成员、方法、以及方法的形参。</p><p>​        2：final修饰成员属性：</p><p>​            1：说明该成员属性是常量，不能被修改。</p><p>​                public static final double PI=3.14;</p><p>​                1：public ：访问权限最大</p><p>​                2：static ：内存中只有一份</p><p>​                3：final  ：是一个常量</p><p>​                4：常量名大写</p><p>​                5：必须初赋值。</p><p>​            2：使用类名.成员。修改该成员的值，报错。–常量不能被修改</p><p>​                1：基本数据类型，final使值不变</p><p>2：对象引用，final使其引用恒定不变，无法让其指向一个新的对象，但是对象自身却可以被修改。</p><p>​                3：该关键字一般和static关键字结合使用</p><p>​                    1：常量可以优先加载，不必等到创建对象的时候再初始化。</p><p>​                4：final和static可以互换位置</p><p>​                5：常量一般被修饰为final</p><p>​            3：fianl修饰类：</p><p>​                1：该类是最终类，不能被继承。</p><p>​                    1：将父类加final修饰，子类继承，就会报错。</p><p>2：查看api文档发现String类是final的。Integer类也是final的</p><p>​                    1：为了防止代码功能被重写</p><p>​                    2：该类没有必要进行扩展</p><p>​            4：final修饰方法：</p><p>​                1：该方法是最终方法，不能被重写</p><p>2：当一个类被继承，那么所有的非私有函数都将被继承，如果函数不想被子类继承并重写可以将该函数final修饰    </p><p>​                3：当一个类中的函数都被修饰为final时，可以将类定义为final的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Father2</span></span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"eating...."</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Son2</span> <span class="keyword">extends</span> <span class="title">Father2</span></span>&#123;</div><div class="line">&gt; <span class="comment">//该方法是最终方法，不能被重写</span></div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"eating...."</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo12</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; </div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// Demo12.PI=300; 无法为最终变量 PI 指定值</span></div><div class="line">&gt; System.out.println(Demo12.PI);</div><div class="line">&gt; Son2 s=<span class="keyword">new</span> Son2();</div><div class="line">&gt; s.eat();</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>5：final关键字修饰形参</p><p>​                1：当形参被修饰为final,那么该形参所属的方法中不能被篡改。</p><p>​                2： 项目中主要用于一些只用来遍历未知数据的函数。将未知变量声明为final的。增强数据的安全性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo14</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; System.out.println();</div><div class="line">&gt; String[] arr = &#123; <span class="string">"think in java"</span>, <span class="string">"java就业教程"</span>, <span class="string">"java核心技术"</span> &#125;;</div><div class="line">&gt;</div><div class="line">&gt; print(arr);</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// 该方法，打印书名。</span></div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">final</span> String[] arr)</span> </span>&#123;</div><div class="line">&gt; <span class="comment">//arr = null; ,无法重新赋值</span></div><div class="line">&gt;</div><div class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</div><div class="line">&gt; System.out.println(arr[x]);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>10：思考</p><p>为什么子类一定要访问父类的构造函数呢</p><p>1：子类继承了父类的属性，如果要使用父类的属性必须初始化，创建子类对象，必须先初始化父类属性</p><p>​                必须调用父类的构造方法。</p><p>2：为什么调用父类无参的构造函数</p><p>设计java语言之时，只知道编译器会默认添加无参的构造函数，有参的无法确定。</p><p>​                但是可以通过super关键字显式调用父类指定构造函数。</p><p>3：为什么super()this()语句要放在构造函数的第一行</p><p>​                子类可能会用到父类的属性，所以必须先初始化父类。</p></blockquote><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><ol><li>静态和非静态的区别。说一下内存。</li></ol><ol><li>成员变量和静态变量的区别？</li><li>静态的特点以及注意事项？</li><li>什么时候使用静态？</li><li>继承的好处？</li><li>java改良多继承的原因？</li><li>当使用一个已存在的继承体系时，该如何更快应用 </li><li>什么时候用继承？</li><li>super和this的特点？</li><li>覆盖的特点，何时应用，注意事项？</li><li>子类的实例化过程？为什么是这样的实例化过程？</li><li>super语句，和this语句为什么不能同时存在，super为什么要定义在第一行？</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本章主要介绍继承、super、从写 、instanceof、final关键子。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://shangrila-kun.github.io/categories/java/"/>
    
    
      <category term="面向对象" scheme="https://shangrila-kun.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>面向对象1</title>
    <link href="https://shangrila-kun.github.io/2018/05/04/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A11/"/>
    <id>https://shangrila-kun.github.io/2018/05/04/面向对象1/</id>
    <published>2018-05-04T00:44:02.000Z</published>
    <updated>2018-05-04T00:46:01.353Z</updated>
    
    <content type="html"><![CDATA[<p>​    本章主要介绍对象、封装、构造方法、构造代码块、内存分享、this关键子、static、main方法。</p><a id="more"></a><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">&gt; 成员变量:  定义在类中变量</div><div class="line">&gt; 局部变量:  定义在方法中变量</div><div class="line">&gt;</div><div class="line">&gt; 成员变量与局部变量的区别：</div><div class="line">&gt; 1.应用范围  </div><div class="line">&gt; 1.成员变量在整个类内都有效    </div><div class="line">&gt; 2.局部变量只在其声明的方法内有效</div><div class="line">&gt; 2.生命周期  </div><div class="line">&gt; 1.成员变量: 它属于对象，它随着对象的创建而创建，随着对象的消失而消失 </div><div class="line">&gt; 2.局部变量: 使用完马上释放空间。</div><div class="line">&gt; void show(int id)&#123;</div><div class="line">&gt; for(int i=0;i&lt;10;i++)&#123;</div><div class="line">&gt;  for(int j=0;j&lt;10;j++)&#123;</div><div class="line">&gt; System.out.println(id);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; 这时候  id,i,j者是在方法内声明的，全是局部变量</div><div class="line">&gt; j当里层for循环执行它的生命周期开始，当里层for结束，j消失</div><div class="line">&gt; i当外层for循环执行它的生命周期开始，当外层for结束，j消失</div><div class="line">&gt; id在方法被调用时开始，方法结束时，id消失.</div><div class="line">&gt; 3.存储位置  成员变量属于对象，它存储在堆内，堆内的实体，当没有引用指向其时，才垃圾回收清理 局部变量存在栈内存中，当不在使用时，马上就会被释放。</div><div class="line">&gt; 4.初始值 </div><div class="line">&gt; 成员变量它存储在堆中，如果没有赋初值，它有默认值。</div><div class="line">&gt; 1.整数byte、short、int、long =0；</div><div class="line">&gt; 2.char=&apos;\uoooo&apos;；</div><div class="line">&gt; 3.boolean =flase；</div><div class="line">&gt; 4.String =null;</div><div class="line">&gt; 5.类类型 =null；</div><div class="line">&gt; 6.数组 =null；</div><div class="line">&gt;     局部变量，如果要想使用必须手动初始化.</div><div class="line">&gt; i.方法中，参数列表中，语句中。</div><div class="line">&gt; ii.必须给初始化值，没有初始值，不能使用</div><div class="line">&gt; iii.在栈内存中</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h3 id="匿名对象"><a href="#匿名对象" class="headerlink" title="匿名对象"></a>匿名对象</h3><h4 id="定义及使用场景"><a href="#定义及使用场景" class="headerlink" title="定义及使用场景"></a>定义及使用场景</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; 2.1匿名对象：没有名字的实体，也就是该实体没有对应的变量名引用。</div><div class="line">&gt; 2.2匿名对象的用途</div><div class="line">&gt; 1，当对象对方法进行一次调用的时候，可以使用匿名对象对代码进行简化。</div><div class="line">&gt;    为什么只对方法，而不调用属性呢？因为匿名对象调用属性没意义。</div><div class="line">&gt;    如果对象要多成员进行多次调用，必须给对象起个名字。不能在使用匿名对象。</div><div class="line">&gt; 2，匿名对象可以实际参数进行传递。</div><div class="line">&gt;     2：匿名对象的简单演示</div><div class="line">&gt; 1：new Car().run(); </div><div class="line">&gt; 3：内存结构图</div><div class="line">&gt; 1：new Car().num=5;</div><div class="line">&gt; 2：new Car().clor=&quot;blue&quot;;</div><div class="line">&gt; 两个new 是两个不同的对象，在堆内存中有不同的空间，相互不相互干扰。</div><div class="line">&gt; 4：匿名对象的使用</div><div class="line">&gt; 1：当只使用一次时可以使用匿名对象。执行完毕到;后该对象就变成了垃圾。</div><div class="line">&gt; new Car().run();</div><div class="line">&gt; 2:执行方法时，可以将匿名对象作为实际参数，传递进去。</div><div class="line">&gt;</div></pre></td></tr></table></figure><p><strong>总结：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt;    1. 匿名对象设置的属性永远无法获取？  没有引用变量指向那个对象。</div><div class="line">&gt;    2. 任何两个匿名对象使用==比较，永远返回false。</div><div class="line">&gt;    3.  匿名对象主要应用于实参。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 封装从字面上来理解就是包装的意思，专业点就是信息隐藏，是指利用抽象数据类型将数据和基于数据的操作封装在一起，使其构成一个不可分割的独立实体，数据被保护在抽象数据类型的内部，尽可能地隐藏内部的细节，只保留一些对外接口使之与外部发生联系。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="封装的好处"><a href="#封装的好处" class="headerlink" title="封装的好处"></a>封装的好处</h4><blockquote><p>对于封装而言，一个对象它所<strong>封装的是自己的属性和方法</strong>，所以它是不需要依赖其他对象就可以完成自己的操作。使用封装有三大好处：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 1、良好的封装能够减少耦合。2、使用比较简单。3、提高对象数据的安全性。4、隐藏了类的属性和实现细节。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="没有封装的案例"><a href="#没有封装的案例" class="headerlink" title="没有封装的案例"></a>没有封装的案例</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; String id;</div><div class="line">&gt; String gender;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(id + <span class="string">":"</span> + name + <span class="string">":"</span> + gender + <span class="string">" 努力工作中！！！"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmployeeDemo</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; <span class="comment">// 创建对象</span></div><div class="line">&gt; Employee jack = <span class="keyword">new</span> Employee();</div><div class="line">&gt; <span class="comment">// 进制通过类名.成员的形式调用成员。初始化实例变量</span></div><div class="line">&gt; jack.name = <span class="string">"jack"</span>;</div><div class="line">&gt; jack.id = <span class="string">"123456"</span>;</div><div class="line">&gt; jack.gender = <span class="string">"男"</span>;</div><div class="line">&gt; <span class="comment">// 调用成员方法</span></div><div class="line">&gt; jack.work();</div><div class="line">&gt; System.out.println();</div><div class="line">&gt; <span class="comment">// 传入非法的参数</span></div><div class="line">&gt; jack.gender = <span class="string">"不是男人"</span>;</div><div class="line">&gt; jack.work();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="封装之后"><a href="#封装之后" class="headerlink" title="封装之后"></a>封装之后</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">private</span> String name;</div><div class="line">&gt; <span class="keyword">private</span> String id;</div><div class="line">&gt; <span class="keyword">private</span> String gender;</div><div class="line">&gt; <span class="comment">// 提供公有的get set方法</span></div><div class="line">&gt; <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> name;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String n)</span> </span>&#123;</div><div class="line">&gt; name = n;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> id;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(String i)</span> </span>&#123;</div><div class="line">&gt; id = i;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> String <span class="title">getGender</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">return</span> gender;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGender</span><span class="params">(String gen)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">if</span> (<span class="string">"男"</span>.equals(gen) || <span class="string">"女"</span>.equals(gen)) &#123;</div><div class="line">&gt; gender = gen;</div><div class="line">&gt; &#125; <span class="keyword">else</span> &#123;</div><div class="line">&gt; System.out.println(<span class="string">"请输入\"男\"或者\"女\""</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(id + <span class="string">":"</span> + name + <span class="string">":"</span> + gender + <span class="string">" 努力工作中！！！"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; 我们人出生的时候，有些人一出生之后再起名字的，但是有些人一旦出生就已经起好名字的。那么我们在java里面怎么在对象一旦创建就赋值呢？</div><div class="line">&gt;</div><div class="line">&gt; 问题：要求每个小孩出生都会哭，这份代码有两个构造函数，如果需要每个小孩出生都要哭的话，那么就需要在不同的构造函数中都调用cry()函数，但是这样子的话造成了代码重复问题，那么怎么解决呢？构造代码块。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>构造方法的作用就是对对象的初始化</strong></p></blockquote><h4 id="与普通的函数的比较"><a href="#与普通的函数的比较" class="headerlink" title="与普通的函数的比较"></a>与普通的函数的比较</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; 1.一般函数是用于定义对象应该具备的功能。而构造函数定义的是，对象在调用功能之前，在建立时，应该具备的一些内容。也就是对象的初始化内容。</div><div class="line">&gt; 2.构造函数是在对象建立时由jvm调用, 给对象初始化。一般函数是对象建立后，当对象调用该功能时才会执行。</div><div class="line">&gt; 3.普通函数可以使用对象多次调用，构造函数就在创建对象时调用。</div><div class="line">&gt; 4.构造函数的函数名要与类名一样，而普通的函数只要符合标识符的命名规则即可。</div><div class="line">&gt; 5.构造函数没有返回值类型。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="构造函数注意的细节"><a href="#构造函数注意的细节" class="headerlink" title="构造函数注意的细节"></a>构造函数注意的细节</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; 1. 当类中没有定义构造函数时，系统会指定给该类加上一个空参数的构造函数。这个是类中默认的构造函数。当类中如果自定义了构造函数，这时默认的构造函数就没有了。</div><div class="line">&gt; 备注：可以通过javap命令验证。</div><div class="line">&gt; 2.在一个类中可以定义多个构造函数，以进行不同的初始化。多个构造函数存在于类中，是以重载的形式体现的。因为构造函数的名称都相同。</div><div class="line">&gt; 4：this只能在非静态中（没有static修饰的）函数使用</div><div class="line">&gt; 3：递归构造函数调用</div><div class="line">&gt; 1：构造函数的相互调用</div><div class="line">&gt; 在编译时期会报错</div><div class="line">&gt; 5：构造函数间相互调用必须放在构造函数的第一个语句中，否则编译错误</div><div class="line">&gt;</div><div class="line">&gt; 6：可以解决构造函数中对象属性和函数形参的同名问题。</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">//构造代码块作用：给所有的对象进行统一的初始化。</span></div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Boy</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; String gender;</div><div class="line">&gt;      <span class="comment">// 构造代码块,给所有对象进行初始化。</span></div><div class="line">&gt; &#123;</div><div class="line">&gt; System.out.println(<span class="string">"哭。。。"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; Boy() &#123;</div><div class="line">&gt; System.out.println(<span class="string">"无参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; Boy(String n, <span class="keyword">int</span> a, String g) &#123;</div><div class="line">&gt; name = n;</div><div class="line">&gt; age = a;</div><div class="line">&gt; gender = g;</div><div class="line">&gt; System.out.println(<span class="string">"有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"跑..."</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo9</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; System.out.println();</div><div class="line">&gt; Boy b = <span class="keyword">new</span> Boy();</div><div class="line">&gt; Boy b2 = <span class="keyword">new</span> Boy(<span class="string">"jack"</span>, <span class="number">1</span>, <span class="string">"男"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; 2：作用</div><div class="line">&gt; 1：给对象进行初始化。对象一建立就运行并且优先于构造函数。</div><div class="line">&gt; 2：与构造函数区别</div><div class="line">&gt; 1：构造代码块和构造函数的区别，构造代码块是给所有对象进行统一初始化， 构造函数给对应的对象初始化。</div><div class="line">&gt; 2：构造代码块的作用：它的作用就是将所有构造方法中公共的信息进行抽取。</div><div class="line">&gt; 例如孩子一出生统一哭</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;  <span class="comment">//构造函数见相互调用</span></div><div class="line">&gt; Student() &#123;</div><div class="line">&gt; <span class="keyword">this</span>(<span class="keyword">null</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;  <span class="comment">//构造函数见相互调用</span></div><div class="line">&gt; Student(String name) &#123;</div><div class="line">&gt; <span class="keyword">this</span>();</div><div class="line">&gt; <span class="keyword">this</span>.name = name;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h2 id="内存分析"><a href="#内存分析" class="headerlink" title="内存分析"></a>内存分析</h2><p>案例</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&gt; //汽车</div><div class="line">&gt; class Car &#123;</div><div class="line">&gt; //汽车应该具备的属性</div><div class="line">&gt; int num;</div><div class="line">&gt; //汽车具备的颜色</div><div class="line">&gt; String color;</div><div class="line">&gt; //汽车跑的行为</div><div class="line">&gt; public void run()&#123;</div><div class="line">&gt; System.out.println(num+&quot;轮子的汽车跑起来啦&quot;);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; public class CarDemo&#123;</div><div class="line">&gt; public static void main(String[] args)</div><div class="line">&gt; &#123;//创建实体，并且给该实体起一个名字</div><div class="line">&gt; Car c = new Car();</div><div class="line">&gt; c.color = &quot;red&quot;;</div><div class="line">&gt; c.num = 4;</div><div class="line">&gt; c.run();//指挥车进行运行。调用格式：对象.对象成员</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7882280-a99eb17ad46943dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="EEE32DD6AB574FB29BECDF403549F497.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; public static void main(String[] args)</div><div class="line">&gt; &#123;//创建实体，并且给该实体起一个名字</div><div class="line">&gt; Car c = new Car();</div><div class="line">&gt; Car c1 = new Car();</div><div class="line">&gt; c.color = &quot;red&quot;;</div><div class="line">&gt; c1.num = 4;</div><div class="line">&gt; System.out.println(c1.color);</div><div class="line">&gt; c.run();//指挥车进行运行。调用格式：对象.对象成员</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7882280-87312d63b5cb668f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="![anli2md.png](http://upload-images.jianshu.io/upload_images/7882280-9c1223cdb185e628.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; public static void main(String[] args)</div><div class="line">&gt; &#123;//创建实体，并且给该实体起一个名字</div><div class="line">&gt; Car c = new Car();</div><div class="line">&gt; Car c1 = c;</div><div class="line">&gt; c.color = &quot;red&quot;;</div><div class="line">&gt; c1.num = 4;</div><div class="line">&gt; c1.color = &quot;green&quot;;</div><div class="line">&gt; System.out.println(c1.color);</div><div class="line">&gt; c.run();//指挥车进行运行。调用格式：对象.对象成员</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7882280-aad1d387197894aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="6(0VNO$BKG`WVC2_Y)2J(GJ.png"></p></blockquote><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><blockquote><p>this关键字代表是对象的引用。也就是this在指向一个对象，所指向的对象就是调用该函数的对象引用。</p></blockquote><h3 id="this设计的使用场景"><a href="#this设计的使用场景" class="headerlink" title="this设计的使用场景"></a>this设计的使用场景</h3><blockquote><p>1：没有this会出现什么问题</p><p>1：定义Person类</p><p>1：有姓名年龄成员变量，有说话的方法。</p><p>2：定义构造方法，无参的，多个有参的。都要实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; <span class="comment">//无参数构造函数</span></div><div class="line">&gt; Person() &#123;</div><div class="line">&gt; System.out.println(<span class="string">"这是无参的构造函数"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//有参数构造函数</span></div><div class="line">&gt; Person(<span class="keyword">int</span> a) &#123;</div><div class="line">&gt; age = a;</div><div class="line">&gt; System.out.println(<span class="string">"有参构造1"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//有参数构造函数</span></div><div class="line">&gt; Person(String n) &#123;</div><div class="line">&gt; name = n;</div><div class="line">&gt; System.out.println(<span class="string">"有参构造2"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//有参数构造函数</span></div><div class="line">&gt; Person(<span class="keyword">int</span> a, String n) &#123;</div><div class="line">&gt; age = a;</div><div class="line">&gt; name = n;</div><div class="line">&gt; System.out.println(<span class="string">"有参构造"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//普通函数</span></div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"hah"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>假设定义40个成员变量，第一个有参构造初始化20个变量，第二个有参构造需要初始化40个变量。</p><p>1：第二个有参构造想要使用第一个有参构造。</p><p>2：成员函数相互之间可以调用。构造函数可以吗？</p><p>3：编译失败，那么构造函数之间应该存在相互调用的模式。this就可以完成这个工作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; Person() &#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Person(String n)&#123;</div><div class="line">&gt; name=n;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Person(String n, <span class="keyword">int</span> a) &#123;</div><div class="line">&gt;         <span class="comment">//编译报错</span></div><div class="line">&gt; Person(n);</div><div class="line">&gt; age = a;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; String gender;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; Student() &#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Student(String name) &#123;</div><div class="line">&gt; <span class="keyword">this</span>();</div><div class="line">&gt; <span class="keyword">this</span>.name = name;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Student(String name, String gender, <span class="keyword">int</span> age) &#123;</div><div class="line">&gt; <span class="keyword">this</span>(name);</div><div class="line">&gt; System.out.println(<span class="keyword">this</span>); <span class="comment">// Student@c17164</span></div><div class="line">&gt; <span class="keyword">this</span>.gender = gender;</div><div class="line">&gt; <span class="keyword">this</span>.age = age;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; run();</div><div class="line">&gt; System.out.println(<span class="string">"姓名："</span> + name + <span class="string">" 性别："</span> + gender + <span class="string">" 年龄："</span> + age</div><div class="line">&gt; + <span class="string">" 哈哈！！！"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"run....."</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; Student p = <span class="keyword">new</span> Student(<span class="string">"jack"</span>, <span class="string">"男"</span>, <span class="number">20</span>);</div><div class="line">&gt; System.out.println(p); <span class="comment">// Student@c17164</span></div><div class="line">&gt; Student p2 = <span class="keyword">new</span> Student(<span class="string">"rose"</span>, <span class="string">"女"</span>, <span class="number">18</span>);</div><div class="line">&gt; System.out.println(p2);</div><div class="line">&gt; p.speak();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>实际工作中，存在着构造函数之间的相互调用，但是构造函数不是普通的成员函数，不能通过函数名自己接调用,所以sun公司提供this关键字。</p><p>this是什么</p><p>1：在构造函数中打印this</p><p>2：创建对象，打印对象名p</p><p>3：this和p是一样的都是内存地址值。</p><p>4：this代表所在函数所属对象的引用。</p></blockquote><h2 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><blockquote><p>java中static可以修饰成员变量、方法、类、代码块.</p><p><strong>static变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; 按照是否静态的对类成员变量进行分类可分两种：</div><div class="line">&gt; 一种是被static修饰的变量，叫静态变量或类变量；</div><div class="line">&gt; 另一种是没有被static修饰的变量，叫实例变量。</div><div class="line">&gt;</div><div class="line">&gt; 两者的区别是：</div><div class="line">&gt;</div><div class="line">&gt; 对于静态变量在内存中只有一个拷贝（节省内存），JVM只为静态分配一次内存，在加载类的过程中完成静态变量的内存分配，可用类名直接访问（方便），当然也可以通过对象来访问（但是这是不推荐的）。对于实例变量，每创建一个实例，就会为实例变量分配一次内存，实例变量可以在内存中有多个拷贝，互不影响（灵活）。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>静态方法</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 静态方法可以直接通过类名调用，任何的实例也都可以调用，因此静态方法中不能用this和super关键字，不能直接访问所属类的实例变量和实例方法(就是不带static的成员变量和成员成员方法)，只能访问所属类的静态成员变量和成员方法。因为实例成员与特定的对象关联！因为static方法独立于任何实例，因此static方法必须被实现，而不能是抽象的abstract。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>static修饰类</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 一般静态内部类可以用static修饰（java内部类分为四种：常规内部类、静态内部类、局部内部类、匿名内部类）。只能访问外部类的static成员，不能直接访问外部类的实例变量与实例方法。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>static语句块</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; 可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块。</div><div class="line">&gt; （1）当一个类中有多个static&#123;&#125;的时候，按照static&#123;&#125;的定义顺序，从前往后执行；</div><div class="line">&gt; （2）先执行完static&#123;&#125;语句块的内容，才会执行调用语句；</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="内存分析-1"><a href="#内存分析-1" class="headerlink" title="内存分析"></a>内存分析</h3><blockquote><p>1：定义Person类</p><p>​        1：姓名、年龄、国籍，说话行为</p><p>​        2：多个构造，重载形式体现</p><p>2：中国人的国籍都是确定的</p><p>​        1：国籍可以进行显示初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; String gender;</div><div class="line">&gt; String country = <span class="string">"CN"</span>;</div><div class="line">&gt; Person() &#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Person(String name, <span class="keyword">int</span> age, String gender, String country) &#123;</div><div class="line">&gt; <span class="keyword">this</span>.name = name;</div><div class="line">&gt; <span class="keyword">this</span>.age = age;</div><div class="line">&gt; <span class="keyword">this</span>.gender = gender;</div><div class="line">&gt; <span class="keyword">this</span>.country = country;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"国籍:"</span> + country + <span class="string">" 姓名："</span> + name + <span class="string">" 性别："</span> + gender + <span class="string">" 年龄："</span> + age + <span class="string">" 哈哈！！！"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>3：new Person 对象</p><p>​        1：分析内存</p><p>​        2：每个对象都维护实例变量国籍也是。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDemo</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; Person p1 = <span class="keyword">new</span> Person(<span class="string">"jack"</span>, <span class="number">20</span>, <span class="string">"男"</span>);</div><div class="line">&gt; p1.speak();</div><div class="line">&gt; Person p2 = <span class="keyword">new</span> Person(<span class="string">"rose"</span>, <span class="number">18</span>, <span class="string">"女"</span>);</div><div class="line">&gt; p2.speak();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>4：内存分析</p><p>​        1：栈，堆、共享区(方法区)</p><p>​        2：Demo.class加载近共享区(方法区)</p><p>​            1：Demo类的main方法进栈</p><p>​            2：Person p1=new Person();</p><p>​                1：Person.class 加载进方法区</p><p>​                2：堆内存开辟空间，实例变量进行默认初始化，显示初始化。</p><p>​                3：内存地址传给变量p1，栈和堆建立连接</p><p>​            3：person p2=new Person();</p><p>​                1：堆内存开辟空间，实例变量进行默认初始化，显示初始化。</p><p>​                2：内存地址传给变量p2，栈和堆建立连接</p><p>​            4：如果建立多个Person对象发现问题</p><p>​                1：每个对象都维护有国籍。</p><p>​    5：解决问题，内存优化</p><p>1：为了让所有Person对象都共享一个country ，可以尝试将country放入共享区。</p><p>​        2：country变量如何放入共享区？对象如何访问？</p><p>​            1：使用static     </p><p>2：static </p><p>​        1：为了实现对象之间重复属性的数据共享</p><p>3：static使用</p><p>​        1：主要用于修饰类的成员</p><p>​            1：成员变量</p><p>​                    1：非静态成员变量：需要创建对象来访问</p><p>​                    2：静态成员变量：使用类名直接调用，也可以通过对象访问</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">&gt; String name;</div><div class="line">&gt; <span class="keyword">int</span> age;</div><div class="line">&gt; String gender;</div><div class="line">&gt; <span class="comment">//static 修饰成员变量</span></div><div class="line">&gt; <span class="keyword">static</span> String country = <span class="string">"CN"</span>;</div><div class="line">&gt; Person() &#123;</div><div class="line">&gt; &#125;</div><div class="line">&gt; Person(String name, <span class="keyword">int</span> age, String gender) &#123;</div><div class="line">&gt; <span class="keyword">this</span>.name = name;</div><div class="line">&gt; <span class="keyword">this</span>.age = age;</div><div class="line">&gt; <span class="keyword">this</span>.gender = gender;</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//非静态方法</span></div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; <span class="comment">//非静态方法可以访问静态成员</span></div><div class="line">&gt; System.out.println(<span class="string">"国籍:"</span> + country );</div><div class="line">&gt; System.out.println(<span class="string">"国籍:"</span> + country + <span class="string">" 姓名："</span> + name + <span class="string">" 性别："</span> + gender</div><div class="line">&gt; + <span class="string">" 年龄："</span> + age + <span class="string">" 哈哈！！！"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="comment">//静态方法</span></div><div class="line">&gt; <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; <span class="comment">//静态方法只能访问静态成员变量。</span></div><div class="line">&gt; System.out.println(<span class="string">"国籍:"</span>+country);</div><div class="line">&gt; <span class="comment">//静态方法访问非静态成员变量，编译报错。</span></div><div class="line">&gt; System.out.println(<span class="string">" 姓名："</span> + name);</div><div class="line">&gt; <span class="comment">//静态方法中不可以出现this,编译报错</span></div><div class="line">&gt; <span class="keyword">this</span>.speak();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>2：细节：</p><p>​        1：静态函数中不能使用非静态变量</p><p>​        2：非静态函数可以访问静态变量</p><p>3：为什么静态函数中不能访问非静态成员</p><p>​        1：static修饰的成员在共享区中。优先于对象存在</p><p>​        2：验证</p><p>​            1：使用静态代码块验证</p><p>​                1：静态代码块</p><p>​                    static{</p><p>​                        静态代码块执行语句;</p><p>​                    }</p><p>​                 1：静态代码块特点</p><p>随着类的加载而加载。只执行一次，优先于主函数。用于给类进行初始化。</p></blockquote><h3 id="static的特点"><a href="#static的特点" class="headerlink" title="static的特点"></a>static的特点</h3><blockquote><p>static特点</p><p>1 随着类的加载而加载，静态会随着类的加载而加载，随着类的消失而消失。说明它的生命周期很长。</p><p>​          2 优先于对象存在。–&gt;静态是先存在，对象是后存在。</p><p>​         3 被所有实例(对象)所共享。</p><p>​          4 可以直接被类名调用    </p><p>5：静态变量（类变量）和实例变量的区别:</p><p>​        1存放位置</p><p>​            1：类变量随着类的加载而加载存在于方法区中.</p><p>​             2：实例变量随着对象的建立而存在于堆内存中.</p><p>​        2生命周期</p><p>​             1：类变量生命周期最长,随着类的消失而消失.</p><p>​             2：实例变量生命周期随着对象的消失而消失.</p><p>6：静态优缺点</p><p>1： 优点:对对象的共享数据进行单独空间的存储,节省空间 例如Person 都有</p><p>国籍。该数据可以共享可以被类名调</p><p>2：缺点：生命周期过长</p><p>​              访问出现局限性。（静态只能访问静态）</p><p>7: 什么时候定义静态变量</p><p>​        1:静态变量（类变量）当对象中出现共享数据</p><p>​          例如：学生的学校名称。学校名称可以共享</p><p>​                对象的数据要定义为非静态的存放在对内存中（学生的姓名，学生的年龄）</p><p>8：什么时候定义静态函数</p><p>如果功能内部没有访问到非静态数据（对象的特有数据。那么该功能就可以定义为静态）                </p><p>9：静态的应用</p><p>​        自定义数组工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 1:定义一个遍历数组的函数</span></div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</div><div class="line">&gt; <span class="keyword">if</span> (x != (arr.length - <span class="number">1</span>)) &#123;</div><div class="line">&gt; System.out.print(arr[x] + <span class="string">","</span>);</div><div class="line">&gt; &#125; <span class="keyword">else</span> &#123;</div><div class="line">&gt; System.out.print(arr[x]);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">// 2:定义一个求数组和的功能函数</span></div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">&gt; <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">&gt; <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</div><div class="line">&gt; sum += arr[x];</div><div class="line">&gt; &#125;</div><div class="line">&gt; <span class="keyword">return</span> sum;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="static加载顺序"><a href="#static加载顺序" class="headerlink" title="static加载顺序"></a>static加载顺序</h3><blockquote><p>（1）当一个类中有多个static{}的时候，按照static{}的定义顺序，从前往后执行；<br>（2）先执行完static{}语句块的内容，才会执行调用语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </div><div class="line">&gt;   </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="number">5</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="number">1</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="keyword">static</span> &#123;  </div><div class="line">&gt;         System.out.println(<span class="number">2</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="keyword">static</span> &#123;  </div><div class="line">&gt;         System.out.println(<span class="number">3</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="keyword">static</span> &#123;  </div><div class="line">&gt;         System.out.println(<span class="number">4</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;<span class="comment">//运行结果为1 2 3 4 5 </span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>如果静态变量在定义的时候就赋给了初值(如 static int X=100)，那么赋值操作也是在类加载的时候完成的，并且当一个类中既有static{}又有static变量的时候，同样遵循“先定义先执行”的原则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;  </div><div class="line">&gt;         <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;  </div><div class="line">&gt;         <span class="keyword">static</span>&#123;  </div><div class="line">&gt;             System.out.println(x);  </div><div class="line">&gt;             x = <span class="number">20</span>;  </div><div class="line">&gt;             System.out.println(x);  </div><div class="line">&gt;         &#125;  </div><div class="line">&gt;         <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;            <span class="keyword">int</span> y = A.x;  </div><div class="line">&gt;         &#125;  </div><div class="line">&gt;     &#125;<span class="comment">//结果为10  20  </span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>通过static来理解类的加载顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>   </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;          <span class="keyword">new</span> B();   </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;  </div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;</div><div class="line">&gt; 运行结果： </div><div class="line">&gt;</div><div class="line">&gt; Static A</div><div class="line">&gt; Static B</div><div class="line">&gt; constructor B</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>类A加载之前首先加载其父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span>  </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;          <span class="keyword">new</span> A();   </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;  </div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;  </div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>类A加载之前首先加载其父类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span>  </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;          <span class="keyword">new</span> A();   </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;  </div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;</div><div class="line">&gt; 结果：</div><div class="line">&gt; Static B</div><div class="line">&gt; Static A</div><div class="line">&gt; constructor B</div><div class="line">&gt; constructor A</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>只有直接定义静态字段X的类才会被初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span>  <span class="keyword">extends</span> <span class="title">B</span></span>&#123;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor A"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;       </div><div class="line">&gt; &#125;  </div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;  </div><div class="line">&gt;     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> x = <span class="number">10</span>;  </div><div class="line">&gt;     <span class="keyword">static</span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"Static B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">B</span><span class="params">()</span></span>&#123;  </div><div class="line">&gt;         System.out.println(<span class="string">"constructor B"</span>);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125;  </div><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;  </div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;  </div><div class="line">&gt;          System.out.println(A.x);  </div><div class="line">&gt;     &#125;  </div><div class="line">&gt; &#125; </div><div class="line">&gt; 结果：</div><div class="line">&gt; Static B</div><div class="line">&gt; <span class="number">10</span></div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="Main方法详解"><a href="#Main方法详解" class="headerlink" title="Main方法详解"></a>Main方法详解</h2><blockquote><p>java虚拟机通过main方法找到需要启动的运行程序，并且检查main函数所在类是否被java虚拟机装载。如果没有装载，那么就装载该类，并且装载所有相关的其他类。因此程序在运行的时候，第一个执行的方法就是<code>main()</code>方法。通常情况下， 如果要运行一个类的方法，必须首先实例化出来这个类的一个对象，然后通过”<strong>对象名.方法名()</strong><code> </code>“的方式来运行方法，但是因为main是程序的入口，这时候还没有实例化对象，因此将main方法声明为static的，这样这个方法就可以直接通过“<strong>类名.方法名() </strong>”的方式来调用。</p><p><strong>先说类</strong></p><p>HelloWorld 类中有<code>main()</code>方法，说明这是个java应用程序，通过JVM直接启动运行的程序。<br>既然是类，java允许类不加public关键字约束，当然类的定义只能限制为public或者无限制关键字（默认的）。</p><p><strong>main()方法</strong></p><p>这个<code>main()</code>方法的声明为：<code>public static void main(String args[])</code> 。必须这么定义，这是Java的规范。</p><p>为什么要这么定义，和JVM的运行有关系。</p><p>当一个类中有<code>main()</code>方法，执行命令“java 类名”则会启动虚拟机执行该类中的main方法。</p><p>由于JVM在运行这个Java应用程序的时候，首先会调用main方法，调用时不实例化这个类的对象，而是通过类名直接调用因此需要是限制为public static。</p><p>对于java中的main方法，jvm有限制，不能有返回值，因此返回值类型为void。</p><p>main方法中还有一个输入参数，类型为String[]，这个也是java的规范，<code>main()</code>方法中必须有一个入参，类细必须<code>String[]</code>，至于字符串数组的名字，这个是可以自己设定的，根据习惯，这个字符串数组的名字一般和sun java规范范例中mian参数名保持一致，取名为args。</p><p>因此，<code>main()</code>方法定义必须是：“<code>public static void main(String 字符串数组参数名[])</code> ”。</p><p><strong>main()方法中可以抛出异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">ExceptionDemo</span></span>&#123;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span><span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">&gt;         System.out.println(<span class="string">"hello"</span>);</div><div class="line">&gt;         <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"error"</span>);</div><div class="line">&gt;    &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><p><strong>main()方法中字符串参数数组作用</strong></p><blockquote><p><code>main()</code>方法中字符串参数数组作用是接收命令行输入参数的，命令行的参数之间用空格隔开。</p><p>下面给出一个例子，看看如何初始化和使用这个数组的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="comment">/**</span></div><div class="line">&gt; * 打印main方法中的输入参数 </div><div class="line">&gt; */</div><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestMain</span> </span>&#123; </div><div class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123; </div><div class="line">&gt;  System.out.println(<span class="string">"打印main方法中的输入参数！"</span>); </div><div class="line">&gt;  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;args.length;i++)&#123; </div><div class="line">&gt;   System.out.println(args[i]); </div><div class="line">&gt;  &#125; </div><div class="line">&gt;  &#125; </div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>实例</strong></p><p>虚拟机通过调用某个指定类的方法main启动，传递给main一个字符串数组参数，使指定的类被装载，同时链接该类所使用的其它的类型，并且初始化它们。例如对于程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloApp</span> </span>&#123;</div><div class="line">&gt;  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt;  System.out.println(<span class="string">"Hello World!"</span>);</div><div class="line">&gt;  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.length; i++) &#123;</div><div class="line">&gt;   System.out.println(args);</div><div class="line">&gt;  &#125;</div><div class="line">&gt;  &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>编译后在命令行模式下键入： java HelloApp run virtual machine</p><p>将通过调用HelloApp的方法main来启动java虚拟机，传递给main一个包含三个字符串”run”、”virtual”、”machine”的数组。现在我们略述虚拟机在执行HelloApp时可能采取的步骤。</p><p>开始试图执行类HelloApp的main方法，发现该类并没有被装载，也就是说虚拟机当前不包含该类的二进制代表，于是虚拟机使用ClassLoader试图寻找这样的二进制代表。如果这个进程失败，则抛出一个异常。类被装载后同时在main方法被调用之前，必须对类HelloApp与其它类型进行链接然后初始化。链接包含三个阶段：检验，准备和解析。检验检查被装载的主类的符号和语义，准备则创建类或接口的静态域以及把这些域初始化为标准的默认值，解析负责检查主类对其它类或接口的符号引用，在这一步它是可选的。类的初始化是对类中声明的静态初始化函数和静态域的初始化构造方法的执行。一个类在初始化之前它的父类必须被初始化。<img src="http://files.jb51.net/file_images/article/201609/20169590759151.jpg?2016859940" alt="img"></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本章主要介绍对象、封装、构造方法、构造代码块、内存分享、this关键子、static、main方法。&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://shangrila-kun.github.io/categories/java/"/>
    
    
      <category term="面向对象" scheme="https://shangrila-kun.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>算法竞赛入门</title>
    <link href="https://shangrila-kun.github.io/2018/05/03/20180503%E7%AE%97%E6%B3%95%E6%B3%95/"/>
    <id>https://shangrila-kun.github.io/2018/05/03/20180503算法法/</id>
    <published>2018-05-03T13:49:08.000Z</published>
    <updated>2018-05-04T00:42:40.776Z</updated>
    
    <content type="html"><![CDATA[<p>​    算法的重要性人人都懂，坚持做下来的不多。曾经为了做一些高大上的项目，对一些基础知识并没有很在乎，以一种不会就百度的心态，现在越来越觉得良好的数据结构知识，有助于项目开发和对程序设计进行抽象出来。为此，现在想重新认识下算法，练习一下”内功”。</p><a id="more"></a><p>##数据类型与输入格式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">11111</span>*<span class="number">11111</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">111111</span>*<span class="number">111111</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,<span class="number">111111111</span>*<span class="number">111111111</span>);</div><div class="line">&#125; <span class="comment">//出现溢出</span></div><div class="line"><span class="number">123454321</span></div><div class="line"><span class="number">-539247567</span></div><div class="line"><span class="number">1653732529</span></div><div class="line"><span class="comment">//当前竞赛流行的平台中，int都是32位，范围是-2的31次到2的31次-1。</span></div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scanf(&quot;%d%d&quot;,&amp;a,&amp;b);</div></pre></td></tr></table></figure><blockquote><p>输入12 2 和属于12        2 和输入12 换行2效果一样。scanf的输入，对空格、TAB和回车都是无关紧要的，所以按Enter键并不意味着输入的结束。</p></blockquote><p>##code test</p><p>###计算e</p><blockquote><p>利用公式e=2+1/2!+1/3!+1/4!+.,编写程序计算无理数e的近似值,直到最后一项小于10-7为止.</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> i = <span class="number">2</span>;</div><div class="line"><span class="keyword">double</span> sum = <span class="number">2.0</span>;</div><div class="line"><span class="keyword">int</span> temp = <span class="number">1</span>;</div><div class="line"><span class="keyword">do</span>&#123;</div><div class="line">temp = temp*i;</div><div class="line">sum +=<span class="number">1.0</span>/temp;</div><div class="line">++i; </div><div class="line">&#125;<span class="keyword">while</span>((<span class="number">1.0</span>/temp)&gt;=<span class="number">1e-7</span>);<span class="comment">//10-7次用1e-7表示。</span></div><div class="line"><span class="built_in">printf</span>(<span class="string">"%.7f\n"</span>,sum);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###计算阶乘之和</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">#include&lt;stdio.h&gt;</div><div class="line">#include&lt;time.h&gt; </div><div class="line">int main()&#123;</div><div class="line">long sum = 0;</div><div class="line">int n;</div><div class="line">long factorial;</div><div class="line">int i = 1;</div><div class="line">scanf("%d",&amp;n);</div><div class="line">do&#123;</div><div class="line">factorial = 1;//每执行一次循环体，都要重新声明并初始化。 </div><div class="line">for(int j = 1;j&lt;=i;j++)&#123;</div><div class="line">factorial*= j;</div><div class="line">&#125;</div><div class="line">sum+=factorial;</div><div class="line">&#125;while(++i&lt;=n&amp;&amp;n&lt;=1000000);</div><div class="line">printf("%ld\n",sum);</div><div class="line">printf("Time used =%.2f\n",(double)clock()/CLOCKS_PER_SEC);//计时器，输出所有时间</div><div class="line"></div><div class="line">return 0; </div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###数据统计fopen</p><blockquote><p>while(scanf(“%d”,&amp;x)==1)是什么意思 相当于  while（1）{scanf(“%d”,&amp;x)}</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> path_in <span class="meta-string">"in.txt"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> path_out <span class="meta-string">"out.txt"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"></div><div class="line">FILE *fin, *fout;</div><div class="line">fout=stout;</div><div class="line"></div><div class="line">fin=fopen(path_in,<span class="string">"wt+"</span>);</div><div class="line"><span class="keyword">if</span>(fin==<span class="literal">NULL</span>) &#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"文件打不开\n"</span>);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line">fout = fopen(path_out,<span class="string">"wt+"</span>);</div><div class="line"><span class="keyword">if</span>(fout == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"><span class="keyword">int</span> x, n = <span class="number">0</span>,min = INF, max = -INF, s = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">fscanf</span>(fin,<span class="string">"%d"</span>,&amp;x)==<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">s += x;</div><div class="line"><span class="keyword">if</span>(x &lt; min) min = x;</div><div class="line"><span class="keyword">if</span>(x &gt; max) max = x;</div><div class="line">n++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">fprintf</span>(fout,<span class="string">"%d %d %.3f\n"</span>, min, max, (<span class="keyword">double</span>)s/n);</div><div class="line">fclose(fin);</div><div class="line">fclose(fout);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCAL</span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1000000000</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> path_in <span class="meta-string">"in.txt"</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> path_out <span class="meta-string">"out.txt"</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> LOCAL</span></div><div class="line">freopen(path_in,<span class="string">"r"</span>,<span class="built_in">stdin</span>);</div><div class="line">freopen(path_out,<span class="string">"w"</span>,<span class="built_in">stdout</span>);</div><div class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></div><div class="line"><span class="keyword">int</span> x, n = <span class="number">0</span>,min = INF, max = -INF, s = <span class="number">0</span>;</div><div class="line"><span class="keyword">while</span> (<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x)==<span class="number">1</span>)</div><div class="line">&#123;</div><div class="line">s += x;</div><div class="line"><span class="keyword">if</span>(x &lt; min) min = x;</div><div class="line"><span class="keyword">if</span>(x &gt; max) max = x;</div><div class="line">n++;</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%d %d %.3f\n"</span>, min, max, (<span class="keyword">double</span>)s/n);</div><div class="line"><span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>重定向的部分被写在了#ifdef 和 #endif中。 只有定义了LOCAL,才编译两条freopen语句。</p><p>中间结果可以写在注释中。好处：一旦需要时，把注释符号去掉即可。</p><p>本机测试时使用重定向方式读写文件。如果比赛要求读写标准输入输出，只需要在提交之前删除#define LOCAL即可。</p><p>**在算法竞赛中，如果不允许使用重定向方式读写数据，应使用fopen和fscanf/fprintf进行输入输出。</p></blockquote><p>###开灯问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> maxn 1010</span></div><div class="line"><span class="keyword">int</span> a[maxn];</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">    <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));<span class="comment">//数组a置为0</span></div><div class="line">    <span class="keyword">int</span> p,t,first;</div><div class="line">    first = <span class="number">0</span>;</div><div class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;t,&amp;p);</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=p;i++)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=t;j++)&#123;</div><div class="line">    <span class="keyword">if</span>(j%i==<span class="number">0</span>)&#123;</div><div class="line">a[j] = !a[j];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=t;i++)&#123;</div><div class="line">    <span class="keyword">if</span>(a[i])&#123;</div><div class="line">    <span class="keyword">if</span>(first)&#123;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">    first=<span class="number">1</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,i);</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>menset(a,0 sizeof(a))的作用是把数组a清零，它在string.h中定义。first是标记变量，用于输出空格格式的调整。</p></blockquote><p>###蛇形数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line"><span class="keyword">int</span> n,x,y,hxnum;</div><div class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;n);</div><div class="line"><span class="keyword">int</span> a[n][n];</div><div class="line"><span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</div><div class="line">x=<span class="number">0</span>;y=n<span class="number">-1</span>;hxnum=<span class="number">1</span>;</div><div class="line">a[x][y] = hxnum;</div><div class="line"><span class="keyword">while</span>(hxnum&lt;n*n)&#123;</div><div class="line"><span class="keyword">while</span>(x&lt;n<span class="number">-1</span>&amp;&amp;!a[x+<span class="number">1</span>][y])&#123;</div><div class="line">a[++x][y]=++hxnum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(y&gt;<span class="number">0</span>&amp;&amp;!a[x][y<span class="number">-1</span>])&#123;</div><div class="line">a[x][--y]=++hxnum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(x&gt;<span class="number">0</span>&amp;&amp;!a[x<span class="number">-1</span>][y])&#123;</div><div class="line">a[--x][y]=++hxnum;</div><div class="line">&#125;</div><div class="line"><span class="keyword">while</span>(y&lt;n<span class="number">-1</span>&amp;&amp;!a[x][y+<span class="number">1</span>])&#123;</div><div class="line">a[x][++y]=++hxnum;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"%3d "</span>,a[i][j]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>###刽子手游戏</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    算法的重要性人人都懂，坚持做下来的不多。曾经为了做一些高大上的项目，对一些基础知识并没有很在乎，以一种不会就百度的心态，现在越来越觉得良好的数据结构知识，有助于项目开发和对程序设计进行抽象出来。为此，现在想重新认识下算法，练习一下”内功”。&lt;/p&gt;
    
    </summary>
    
      <category term="算法" scheme="https://shangrila-kun.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="c语言竞赛" scheme="https://shangrila-kun.github.io/tags/c%E8%AF%AD%E8%A8%80%E7%AB%9E%E8%B5%9B/"/>
    
  </entry>
  
  <entry>
    <title>线程及其在java方面的应用</title>
    <link href="https://shangrila-kun.github.io/2018/04/01/20180401-%E7%BA%BF%E7%A8%8B/"/>
    <id>https://shangrila-kun.github.io/2018/04/01/20180401-线程/</id>
    <published>2018-04-01T05:56:01.000Z</published>
    <updated>2018-04-09T13:47:13.959Z</updated>
    
    <content type="html"><![CDATA[<p>​    一些关于线程的事</p><a id="more"></a><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><blockquote><p>线程，有时被称为轻量级进程(Lightweight Process，LWP），是程序执行流的最小单元。一个标准的线程由线程ID，当前指令<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88" target="_blank" rel="noopener">指针</a>(PC），<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a>集合和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>组成。另外，线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。一个线程可以创建和撤消另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。线程也有<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA" target="_blank" rel="noopener">就绪</a>、<a href="https://baike.baidu.com/item/%E9%98%BB%E5%A1%9E" target="_blank" rel="noopener">阻塞</a>和<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>三种基本状态。就绪状态是指线程具备运行的所有条件，逻辑上可以运行，在等待处理机；运行状态是指线程占有处理机正在运行；阻塞状态是指线程在等待一个事件（如某个信号量），逻辑上不可执行。每一个程序都至少有一个线程，若程序只有一个线程，那就是程序本身。</p></blockquote><p>###线程的特点</p><blockquote><p>在早期的操作系统中并没有线程的概念，进程是能拥有资源和独立运行的最小单位，也是程序执行的最小单位。任务调度采用的是时间片轮转的抢占式调度方式，而进程是任务调度的最小单位，每个进程有各自独立的一块内存，使得各个进程之间内存地址相互隔离。</p><p>后来，随着计算机的发展，对CPU的要求越来越高，进程之间的切换开销较大，已经无法满足越来越复杂的程序的要求了。于是就发明了线程，线程是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间(也就是所在进程的内存空间)。一个标准的线程由线程ID、当前指令指针(PC)、寄存器和堆栈组成。而进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成。</p><p>在<a href="https://baike.baidu.com/item/%E5%A4%9A%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener">多线程</a>OS中，通常是在一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>1) <strong>轻型实体</strong></p><blockquote><p>线程中的实体基本上不拥有<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90" target="_blank" rel="noopener">系统资源</a>，只是有一点必不可少的、能保证独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的资源。</p><p>线程的实体包括程序、数据和TCB。线程是动态概念，它的动态特性由线程控制块TCB（Thread Control Block）描述。</p></blockquote><p>2)<strong>独立调度和分配的基本单位</strong></p><blockquote><p>在多线程OS中，线程是能独立<a href="https://baike.baidu.com/item/%E8%BF%90%E8%A1%8C" target="_blank" rel="noopener">运行</a>的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的）。</p></blockquote><p>3)<strong>可并发执行</strong></p><blockquote><p>在一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>与外围设备并行工作的能力。</p></blockquote><p><strong>4）共享</strong><a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>资源。</p><blockquote><p>在同一<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的<a href="https://baike.baidu.com/item/%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4" target="_blank" rel="noopener">地址空间</a>（进程的地址空间），这意味着，线程可以访问该地址空间的每一个虚地址；此外，还可以访问进程所拥有的已打开<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>、定时器、<a href="https://baike.baidu.com/item/%E4%BF%A1%E5%8F%B7%E9%87%8F" target="_blank" rel="noopener">信号量</a>机构等。由于同一个<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">进程</a>内的线程<a href="https://baike.baidu.com/item/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98" target="_blank" rel="noopener">共享内存</a>和<a href="https://baike.baidu.com/item/%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">文件</a>，所以线程之间互相通信不必调用<a href="https://baike.baidu.com/item/%E5%86%85%E6%A0%B8" target="_blank" rel="noopener">内核</a>。</p></blockquote></blockquote><h3 id="线程的同步"><a href="#线程的同步" class="headerlink" title="线程的同步"></a>线程的同步</h3><blockquote><p>同步就是协同步调，按预定的先后次序进行运行。如：你说完，我再说。</p><p>进程、线程同步，可理解为进程或线程A和B一块配合，A执行到一定程度时要依靠B的某个结果，于是停下来，示意B运行；B依言执行，再将结果给A；A再继续操作。</p></blockquote><p><strong>同步需要解决的问题</strong></p><blockquote><p>在多线程编程里面，一些敏感数据不允许被多个线程同时访问，此时就使用同步访问技术，保证数据在任何时刻，最多有一个线程访问，以保证数据的完整性。</p><p>线程同步：即当有一个线程在对内存进行操作时，其他线程都不可以对这个内存地址进行操作，直到该线程完成操作， 其他线程才能对该内存地址进行操作，而其他线程又处于等待状态，目前实现线程同步的方法有很多，临界区对象就是其中一种。</p></blockquote><h3 id="java单线程"><a href="#java单线程" class="headerlink" title="java单线程"></a>java单线程</h3><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">package</span> com.haoeasy.thread;</div><div class="line">&gt; <span class="comment">/**</span></div><div class="line">&gt;  * Created by HUANGKUN on 2018/4/1.</div><div class="line">&gt;  */</div><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleThread</span> </span>&#123;</div><div class="line">&gt;     <span class="comment">/*单线程*/</span></div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pintfor</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">&gt;             String threadName = Thread.currentThread().getName();</div><div class="line">&gt;             System.out.println(threadName);</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</div><div class="line">&gt;         SingleThread.pintfor();</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>out : 10个main.main函数的默认线程是main。</p></blockquote><h3 id="java创建线程"><a href="#java创建线程" class="headerlink" title="java创建线程"></a>java创建线程</h3><blockquote><p>单线程程序简单明了，但有时无法满足特定的需求。如一个文字处理的程序，我在打印文章的同时也要能对文字进行编辑，如果是单线程的程序则要等打印机打印完成之后你才能对文字进行编辑，但打印的过程一般比较漫长，这是我们无法容忍的。如果采用多线程，打印的时候可以单独开一个线程去打印，主线程可以继续进行文字编辑。在程序需要同时执行多个任务时，可以采用多线程。</p><p>在程序需要同时执行多个任务时，可以采用多线程。Java给多线程编程提供了内置的支持，提供了两种创建线程方法：1.通过实现Runable接口；2.通过继承Thread类。</p><p>Thread是JDK实现的对线程支持的类，Thread类本身实现了Runnable接口，所以Runnable是显示创建线程必须实现的接口; Runnable只有一个run方法，所以不管通过哪种方式创建线程，都必须实现run方法。我们可以看一个例子。</p></blockquote><p>####实现runnable</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">package</span> com.haoeasy.thread;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">/**</span></div><div class="line">&gt;  * Created by HUANGKUN on 2018/4/1.</div><div class="line">&gt;  */</div><div class="line">&gt; <span class="comment">/**</span></div><div class="line">&gt;  * 通过实现runnable方法</div><div class="line">&gt;  * */</div><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</div><div class="line">&gt;     <span class="keyword">private</span> Thread thread;</div><div class="line">&gt;     <span class="keyword">private</span> String threadName;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadA</span><span class="params">(String threadName)</span></span>&#123;</div><div class="line">&gt;         thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>,threadName);</div><div class="line">&gt;         <span class="keyword">this</span>.threadName = threadName;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="comment">/**</span></div><div class="line">&gt;      * 实现run方法</div><div class="line">&gt;      * */</div><div class="line">&gt;     <span class="meta">@Override</span></div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt;         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">&gt;         <span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">&gt;             System.out.println(threadName+<span class="string">":"</span>+i);</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;         thread.start();</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h4 id="实现thread"><a href="#实现thread" class="headerlink" title="实现thread"></a>实现thread</h4><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadB</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</div><div class="line">&gt;     <span class="keyword">private</span> String threadName;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="title">ThreadB</span><span class="params">(String threadName)</span></span>&#123;</div><div class="line">&gt;         <span class="keyword">super</span>();</div><div class="line">&gt;         <span class="keyword">this</span>.threadName = threadName;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="comment">//实现run方法</span></div><div class="line">&gt;     <span class="meta">@Override</span></div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;         <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">&gt;         <span class="keyword">for</span>(;i&lt;<span class="number">10</span>;i++)&#123;</div><div class="line">&gt;             System.out.println(threadName+<span class="string">":"</span>+i);</div><div class="line">&gt;         &#125;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">package</span> com.haoeasy.thread;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">/**</span></div><div class="line">&gt;  * Created by HUANGKUN on 2018/4/1.</div><div class="line">&gt;  */</div><div class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThread</span> </span>&#123;</div><div class="line">&gt;     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span></span>&#123;</div><div class="line">&gt;         ThreadA threadA = <span class="keyword">new</span> ThreadA(<span class="string">"ThreadA"</span>);</div><div class="line">&gt;         ThreadB threadB = <span class="keyword">new</span> ThreadB(<span class="string">"ThreadB"</span>);</div><div class="line">&gt;         threadA.start();</div><div class="line">&gt;         threadB.start();</div><div class="line">&gt;     &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>out:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; ThreadA:0</div><div class="line">&gt; ThreadB:0</div><div class="line">&gt; ThreadA:1</div><div class="line">&gt; ThreadB:1</div><div class="line">&gt; ThreadA:2</div><div class="line">&gt; ThreadA:3</div><div class="line">&gt; ThreadA:4</div><div class="line">&gt; ThreadA:5</div><div class="line">&gt; ThreadB:2</div><div class="line">&gt; ThreadA:6</div><div class="line">&gt; ThreadB:3</div><div class="line">&gt; ThreadA:7</div><div class="line">&gt; ThreadB:4</div><div class="line">&gt; ThreadA:8</div><div class="line">&gt; ThreadA:9</div><div class="line">&gt; ThreadB:5</div><div class="line">&gt; ThreadB:6</div><div class="line">&gt; ThreadB:7</div><div class="line">&gt; ThreadB:8</div><div class="line">&gt; ThreadB:9</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>说明：上面的例子中例举了两种实现线程的方式。大部分情况下选择实现Runnable接口的方式会优于继承Thread的方式，因为： </p><ol><li>从 Thread 类继承会强加类层次； </li><li>有些类不能继承Thread类，如要作为线程运行的类已经是某一个类的子类了，但Java只支持单继承，所以不能再继承Thread类了。</li></ol></blockquote><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><blockquote><p><a href="https://blog.csdn.net/luoweifu/article/details/46595285" target="_blank" rel="noopener">编程思想之多线程与多进程(1)——以操作系统的角度述说线程与进程</a></p><p><a href="https://blog.csdn.net/luoweifu/article/details/46673975" target="_blank" rel="noopener">编程思想之多线程与多进程(3)——Java中的多线程</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    一些关于线程的事&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shangrila-kun.github.io/categories/linux/"/>
    
    
      <category term="线程" scheme="https://shangrila-kun.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>20180331-进程</title>
    <link href="https://shangrila-kun.github.io/2018/03/31/20180331-%E8%BF%9B%E7%A8%8B/"/>
    <id>https://shangrila-kun.github.io/2018/03/31/20180331-进程/</id>
    <published>2018-03-31T06:29:41.000Z</published>
    <updated>2018-04-01T05:49:16.039Z</updated>
    
    <content type="html"><![CDATA[<p>​    主要介绍了关于进程及其相关的知识，更详细内容还需看书。感觉linux进程很深奥，很有意思。</p><a id="more"></a><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h3><blockquote><p>在早期面向进程设计的计算机结构中，<strong>进程是程序的基本执行实体</strong>；在当代面向线程设计的计算机结构中，<strong>进程是线程的容器</strong>。程序是指令、数据及其组织形式的描述(静态)，进程是程序的实体（运动的，在执行中）。即进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。它不只是程序的<strong>代码</strong>，还包括当前的活动，通过<strong>程序计数器</strong>的值和处理<strong>寄存器</strong>的内容来表示。</p></blockquote><p><strong>进程的概念主要有两点</strong></p><blockquote><p>第一，进程是一个实体。</p><blockquote><p>每一个进程都有它自己的地址空间，一般情况下，包括<a href="https://baike.baidu.com/item/%E6%96%87%E6%9C%AC" target="_blank" rel="noopener">文本</a>区域（text region）、数据区域（data region）和<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88" target="_blank" rel="noopener">堆栈</a>（stack region）。文本区域存储处理器执行的代码；数据区域存储变量和进程执行期间使用的动态分配的内存；堆栈区域存储着活动过程调用的指令和本地变量。</p></blockquote><p>第二，进程是一个“执行中的程序”。</p><blockquote><p>程序是一个没有生命的实体，只有处理器赋予程序生命时（操作系统执行之），它才能成为一个活动的实体，我们称其为进程。</p></blockquote></blockquote><h3 id="操作系统引入进程的原因"><a href="#操作系统引入进程的原因" class="headerlink" title="操作系统引入进程的原因"></a>操作系统引入进程的原因</h3><blockquote><p>从理论角度看，是对正在运行的程序过程的抽象。</p><p>从实现角度看，是一种数据结构，目的在于清晰地刻画动态系统的内在规律，有效管理和调度进入计算机系统主存储器运行的程序。</p></blockquote><h3 id="进程的基本特征是什么"><a href="#进程的基本特征是什么" class="headerlink" title="进程的基本特征是什么"></a>进程的基本特征是什么</h3><blockquote><p>动态性</p><blockquote><p>进程的实质是程序在多道程序系统中的一次执行过程，进程是动态产生，动态消亡的。</p><blockquote><p>多道程序系统是指计算机内存中同时存放几道相互独立的程序，使他们在管理程序控制下，相互穿插的运行。 两个或两个以上程序在计算机系统中同处于开始和结束之间的状态。引入多道程序设计技术的根本目的是为了提高CPU的利用率，充分发挥计算机系统部件的并发行，现在计算机系统都采用了多道程序设计技术。</p></blockquote></blockquote><p>并发性</p><blockquote><p>任何进程都可以同其他进程一起并发执行。宏观上并发，微观上串行。</p></blockquote><p>独立性</p><blockquote><p>进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。</p></blockquote><p>异步性</p><blockquote><p>由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的，不可预知的速度向前推进。</p></blockquote></blockquote><h3 id="进程和程序的区别"><a href="#进程和程序的区别" class="headerlink" title="进程和程序的区别"></a>进程和程序的区别</h3><blockquote><p>（1）程序是永存的，是一组指令的有序集合；进程是暂时的，是程序在数据集上的一次执行，有生命周期；</p><p> （2）程序是静态的观念，进程是动态的观念；</p><p> （3）进程具有并发性，而程序没有；</p><p> （4）进程是竞争计算机资源的基本单位，程序不是。</p><p> （5）进程和程序不是一一对应的： 一个程序可对应多个进程即多个进程可执行同一程序； 一个进程可以执行一个或几个程序</p></blockquote><h3 id="进程的基本状态和转换"><a href="#进程的基本状态和转换" class="headerlink" title="进程的基本状态和转换"></a>进程的基本状态和转换</h3><blockquote><p>进程执行时的间断性，决定了进程可能具有多种状态。事实上，运行中的进程可能具有以下三种基本状态。</p><p>1）就绪状态（Ready）：<br>​    进程已获得除处理器外的所需资源，等待分配处理器资源；只要分配了处理器进程就可执行。就绪进程可以按多个优先级来划分队列。例如，当一个进程由于时间片用完而进入就绪状态时，排入低优先级队列；当进程由I/O操作完成而进入就绪状态时，排入高优先级队列。<br>2）运行状态(Running)：<br>​    进程占用处理器资源；处于此状态的进程的数目小于等于处理器的数目。在没有其他进程可以执行时(如所有进程都在阻塞状态)，通常会自动执行系统的空闲进程。<br>3）阻塞状态(Blocked)：<br>​    由于进程等待某种条件（如I/O操作或进程同步），在条件满足之前无法继续执行。该事件发生前即使把处理器资源分配给该进程，也无法运行。</p><blockquote><p>同步的概念</p><p>​    我们把异步环境下的一组并发进程因直接制约而互相发送消息、进行互相合作、互相等待，使得各进程按一定的速度执行的过程称为进程间的同步。具有同步关系的一组并发进程称为<a href="https://baike.baidu.com/item/%E5%90%88%E4%BD%9C%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">合作进程</a>，合作进程间互相发送的信号称为消息或事件。 如果我们对一个消息或事件赋以唯一的消息名，则我们可用过程　wait (消息名)　 表示进程等待<a href="https://baike.baidu.com/item/%E5%90%88%E4%BD%9C%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener">合作进程</a>发来的消息，而用过程　signal (消息名) 表示向合作进程发送消息。</p></blockquote><p><strong>转换</strong></p><p><img src="https://images2015.cnblogs.com/blog/273421/201704/273421-20170411100345079-2080566903.jpg" alt="img"></p><blockquote><p>就绪状态 -&gt; 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。</p><p>运行状态 -&gt; 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。</p><p>运行状态 -&gt; 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</p><p>阻塞状态 -&gt; 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。</p></blockquote></blockquote><h3 id="进程控制块"><a href="#进程控制块" class="headerlink" title="进程控制块"></a>进程控制块</h3><p><strong>是什么</strong></p><blockquote><p>进程控制块(PCB Processing Control Block)是系统为了管理进程设置的一个专门的数据结构。</p><p>记载着如下信息</p><blockquote><ul><li><a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8" target="_blank" rel="noopener">程序计数器</a>：接着要运行的指令地址。</li><li>进程状态：可以是new、ready、running、waiting或 blocked等。</li><li><a href="https://baike.baidu.com/item/CPU" target="_blank" rel="noopener">CPU</a><a href="https://baike.baidu.com/item/%E6%9A%82%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">暂存器</a>：如<a href="https://baike.baidu.com/item/%E7%B4%AF%E5%8A%A0%E5%99%A8" target="_blank" rel="noopener">累加器</a>、索引暂存器（Index register）、<a href="https://baike.baidu.com/item/%E5%A0%86%E6%A0%88%E6%8C%87%E9%92%88" target="_blank" rel="noopener">堆栈指针</a>以及一般用途暂存器、状况代码等，主要用途在于中断时暂时存储数据，以便稍后继续利用；其数量及类因电脑架构有所差异。</li><li>CPU排班法：优先级、排班队列等指针以及其他参数。</li><li><a href="https://baike.baidu.com/item/%E5%AD%98%E5%82%A8%E5%99%A8" target="_blank" rel="noopener">存储器</a>管理：如标签页表等。</li><li>会计信息：如CPU与实际时间之使用数量、时限、账号、工作或进程号码。</li><li>输入输出状态：配置进程使用<a href="https://baike.baidu.com/item/I%2FO" target="_blank" rel="noopener">I/O</a>设备，如<a href="https://baike.baidu.com/item/%E7%A3%81%E5%B8%A6%E6%9C%BA" target="_blank" rel="noopener">磁带机</a>。 [1]<a href=""> </a></li></ul></blockquote></blockquote><p><strong>作用</strong></p><blockquote><p>系统用它来记录进程的外部特征，描述进程的运动变化过程。同时，系统可以利用PCB来控制和管理进程，所以说，PCB（进程控制块）是系统感知进程存在的<strong>唯一标志</strong>。</p></blockquote><h3 id="Linux的进程控制"><a href="#Linux的进程控制" class="headerlink" title="Linux的进程控制"></a>Linux的进程控制</h3><h4 id="进程的创建与映像更换"><a href="#进程的创建与映像更换" class="headerlink" title="进程的创建与映像更换"></a>进程的创建与映像更换</h4><blockquote><p>进程不能凭空出世，它是由另一个进程创建的。新创建的进程称为子进程，创建子进程的称为父进程。系统中所有进程都是由1号进程init的子孙进程创建的。</p><p><strong>fork()系统调用</strong></p><blockquote><p>若fork()调用成功，它向父进程返回子进程的PID,并向新建的子进程返回0。</p></blockquote><p><strong>更换进程映像</strong></p><blockquote><p>通常用户需要的是创建一个新进程来执行某个指定的程序。linux系统的做法是创建子进程后，在子进程中调用exec（）来更换进程映像，使自己脱胎换骨，变为一个全新的进程。</p><p>exec()系统调用的功能是根据参数指定的路径名找到可执行文件，把它装入进程中的地址空间，覆盖原来的进程映像，从而形成一个不同于父进程的全新的子进程。除了进程映像被更换外，子进程的其他PCB属性均保持不变，就像一个新的进程借壳原来的子进程开始运行。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">&gt; &gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">&gt; &gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">&gt; &gt;     <span class="keyword">int</span> rid;</div><div class="line">&gt; &gt;     rid = fork();</div><div class="line">&gt; &gt;     <span class="keyword">if</span>(rid&gt;<span class="number">0</span>)&#123;</div><div class="line">&gt; &gt; <span class="built_in">printf</span>(<span class="string">"i am parent \n"</span>);</div><div class="line">&gt; &gt;     &#125;<span class="keyword">else</span>&#123;</div><div class="line">&gt; &gt; <span class="built_in">printf</span>(<span class="string">"i ma child i will change to echo \n"</span>);</div><div class="line">&gt; &gt; execl(<span class="string">"/bin/echo"</span>,<span class="string">"echo"</span>,<span class="string">"hello"</span>,<span class="number">0</span>);</div><div class="line">&gt; &gt;     &#125;</div><div class="line">&gt; &gt;     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&gt; &gt; &#125;</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote></blockquote><p>####进程的终止和等待</p><blockquote><p>导致一个进程终止运行的方式有两种：使用退出语句主动退出，我们称之为正常终止；另一种是被某个信号所杀死，我们称为非正常终止。</p><p>c语言编程时，以下4种主动终止运行的方式。</p><blockquote><p>调用exit(status)函数来结束程序。</p><p>在main（）函数中使用return status语句结束。</p><p>在main（） 函数中用return语句结束。</p><p>程序执行至main函数结束。（隐式的终止）</p></blockquote></blockquote><h3 id="Linux是如何创建进程的"><a href="#Linux是如何创建进程的" class="headerlink" title="Linux是如何创建进程的"></a>Linux是如何创建进程的</h3><blockquote><p>首先，要明白这样一个事情：在内核启动的时候会生成0号进程；之后0号进程创建1号进程和2号进程；再之后1号进程是所有用户态进程的祖先，2号进程是所有内核线程的祖先。也就是我们使用操作系统创建进程和线程的时候都不是原始的编写一个出来的，而是通过复制并修改父进程的结构得来的。<br>说起进程的结构就不得不提起PCB（进程控制块）。PCB是描述一个进程的数据块。在内核中对应task_struct代码。而子进程的PCB是复制并修改父进程的PCB得来的。那么就有必要看一看PCB也就是task_struct中到底定义了什么。这里得交代一下，task_struct结构体有400多行代码，结构复杂不易理解。这里我贴出一份博客，那里有详细的解释。请<strong>各位看官务必先阅读下这篇详解task_struct的博客</strong><a href="http://blog.csdn.net/jnu_simba/article/details/11724277" target="_blank" rel="noopener">http://blog.csdn.net/jnu_simba/article/details/11724277</a>。我也一并贴出task_struct源码的地址，如有兴趣请进去查阅<a href="http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235" target="_blank" rel="noopener">http://codelab.shiyanlou.com/xref/linux-3.18.6/include/linux/sched.h#1235</a>。</p><p>之后，我们从具体的内核函数来分析一下创建进程的具体流程。<br>创建一个进程可以通过clone(),fork(),vfork()这三个系统调用来完成。而这三个系统调用都是由do_fork()函数来负责处理。在《深入理解Linux内核（第三版）》中写到，实现clone()系统调用的是sys_clone()服务例程，实现fork()系统调用的是clone()，实现vfork()的也是clone()。但是负责处理clone(),fork()和vfork()的函数是do_fork()。概括的流程就是：clone(),fork(),vfork()——&gt;sys_clone()——&gt;do_fork()。</p><p>具体细节可以点击<a href="https://blog.csdn.net/shazhoulada1/article/details/44957707" target="_blank" rel="noopener">访问</a></p></blockquote><h4 id="创建进程示例1"><a href="#创建进程示例1" class="headerlink" title="创建进程示例1"></a>创建进程示例1</h4><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;     <span class="keyword">pid_t</span> fpid;<span class="comment">//fpid表示fork函数返回的值</span></div><div class="line">&gt;     <span class="keyword">int</span> count = <span class="number">0</span>;</div><div class="line">&gt;     fpid = fork();</div><div class="line">&gt;     <span class="keyword">if</span>(fpid &lt; <span class="number">0</span>)</div><div class="line">&gt;     &#123;</div><div class="line">&gt;         <span class="built_in">printf</span>(<span class="string">"error in fork!\n"</span>);</div><div class="line">&gt;     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(fpid == <span class="number">0</span>)&#123;</div><div class="line">&gt;         <span class="built_in">printf</span>(<span class="string">"i am the child process,my process id is %d \n"</span>,getpid());</div><div class="line">&gt;         count++;</div><div class="line">&gt;     &#125;<span class="keyword">else</span>&#123;</div><div class="line">&gt;         <span class="built_in">printf</span>(<span class="string">" i am the parent process,my process id is %d \n"</span>,getpid());</div><div class="line">&gt;         count++;</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="built_in">printf</span>(<span class="string">"统计结果是：%d \n"</span>,count);</div><div class="line">&gt;     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>结果如下：</p><p>i am the parent process,my process id is 12379<br>统计结果是：1<br>i am the child process,my process id is 12380<br>统计结果是：1</p></blockquote><h4 id="示例讲解"><a href="#示例讲解" class="headerlink" title="示例讲解"></a>示例讲解</h4><blockquote><p>fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事，但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。<br>一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。</p><p>在语句fpid=fork()之前，只有一个进程在执行这段代码，但在这条语句之后，就变成两个进程在执行了，这两个进程的几乎完全相同，将要执行的下一条语句都是if(fpid&lt;0)……<br>为什么两个进程的fpid不同呢，这与fork函数的特性有关。fork调用的一个奇妙之处就是它仅仅被调用一次，却能够返回两次，它可能有三种不同的返回值：<br>1）在父进程中，fork返回新创建子进程的进程ID；<br>2）在子进程中，fork返回0；<br>3）如果出现错误，fork返回一个负值；</p><p>在fork函数执行完毕后，如果创建新进程成功，则出现两个进程，一个是子进程，一个是父进程。在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。</p><p>引用一位网友的话来解释fpid的值为什么在父子进程中不同。“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0.<br>fork出错可能有两种原因：<br>1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。<br>2）系统内存不足，这时errno的值被设置为ENOMEM。<br>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程执行没有固定的先后顺序，哪个进程先执行要看系统的进程调度策略。<br>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。<br>fork执行完毕后，出现两个进程。</p><p><img src="http://files.jb51.net/file_images/article/201606/2016622152015141.gif?2016522152036" alt="2016622152015141.gif (557×381)"></p></blockquote><h4 id="创建进阶进程示例2"><a href="#创建进阶进程示例2" class="headerlink" title="创建进阶进程示例2"></a>创建进阶进程示例2</h4><blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line">&gt; <span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line">&gt; <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</div><div class="line">&gt;     <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">&gt;     <span class="built_in">printf</span>(<span class="string">"i  son/pa ppid pid fpid \n"</span>);</div><div class="line">&gt;     <span class="comment">//ppid指当前进程的父进程pid</span></div><div class="line">&gt;     <span class="comment">//pid指当前进程的pid</span></div><div class="line">&gt;     <span class="comment">//fpid指fork返回给当前进程的值</span></div><div class="line">&gt;     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123;</div><div class="line">&gt;         <span class="keyword">pid_t</span> fpid = fork();</div><div class="line">&gt;         <span class="keyword">if</span>(fpid==<span class="number">0</span>)</div><div class="line">&gt;             <span class="built_in">printf</span>(<span class="string">"%d child %4d %4d %4d \n"</span>,i,getppid(),getpid(),fpid);</div><div class="line">&gt;         <span class="keyword">else</span></div><div class="line">&gt;             <span class="built_in">printf</span>(<span class="string">"%d parent %4d %4d %4d \n"</span>,i,getppid(),getpid(),fpid);</div><div class="line">&gt;     &#125;</div><div class="line">&gt;     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>执行结果</strong></p><blockquote><p>i  son/pa ppid pid fpid</p><p>0 parent 2043 3224 3225<br>0 child 3224 3225  0<br>1 parent 2043 3224 3226<br>1 parent 3224 3225 3227<br>1 child   1 3227  0<br>1 child   1 3226  0 </p></blockquote><p><strong>分析</strong></p><p>​    <strong>第一步</strong> </p><blockquote><p>在父进程中，指令执行到for循环中，i=0,接着执行fork,fork执行完后，系统中出现两个进程，分别是3224 ,3225 （后面我都用pxxxx表示进程id为xxxx的进程）。可以看到父进程p3224的父进程是p2043，子进程p3225的父进程正好是p3224。我们用一个链表来表示这个关系：p2043-&gt;p3224-&gt;p3225 </p><p>第一次fork后，p3224（父进程）的变量为i=0，fpid=3225（fork函数在父进程中返向子进程id），代码内容为:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)&#123; </div><div class="line">&gt; &gt;   <span class="keyword">pid_t</span> fpid=fork();<span class="comment">//执行完毕，i=0，fpid=3225 和 0 </span></div><div class="line">&gt; &gt;   <span class="keyword">if</span>(fpid==<span class="number">0</span>) </div><div class="line">&gt; &gt;     <span class="built_in">printf</span>(<span class="string">"%d child %4d %4d %4d/n"</span>,i,getppid(),getpid(),fpid); </div><div class="line">&gt; &gt;   <span class="keyword">else</span></div><div class="line">&gt; &gt;     <span class="built_in">printf</span>(<span class="string">"%d parent %4d %4d %4d/n"</span>,i,getppid(),getpid(),fpid); </div><div class="line">&gt; &gt; &#125; </div><div class="line">&gt; &gt; <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>打印结果</p><blockquote><p>parent 2043 3224 3225<br>0 child 3224 3225  0</p></blockquote></blockquote><p>​    <strong>第二步</strong></p><pre><code>&gt; 假设父进程p3224先执行，当进入下一个循环时，i=1，接着执行fork，系统中又新增一个进程p3226，对于此时的父进程，p2043-&gt;p3224（当前进程）-&gt;p3226（被创建的子进程）。&gt; 对于子进程p3225，执行完第一次循环后，i=1，接着执行fork，系统中新增一个进程p3227，对于此进程，p3224-&gt;p3225（当前进程）-&gt;p3227（被创建的子进程）。从输出可以看到p3225原来是p3224的子进程，现在变成p3227的父进程。父子是相对的，这个大家应该容易理解。只要当前进程执行了fork，该进程就变成了父进程了，就打印出了parent。&gt; 所以打印出结果是：&gt;&gt; 打印结果&gt;&gt; &gt; 1 parent 2043 3224 3226&gt; &gt; 1 parent 3224 3225 3227</code></pre><p>​    <strong>第三步</strong></p><blockquote><p>第二步创建了两个进程p3226，p3227，这两个进程执行完printf函数后就结束了，因为这两个进程无法进入第三次循环，无法fork，该执行return 0;了，其他进程也是如此。<br>以下是p3226，p3227打印出的结果：</p><p>1 child   1 3227  0<br>1 child   1 3226  0</p><p>细心的读者可能注意到p3226，p3227的父进程难道不该是p3224和p3225吗，怎么会是1呢？这里得讲到进程的创建和死亡的过程，在p3224和p3225执行完第二个循环后，main函数就该退出了，也即进程该死亡了，因为它已经做完所有事情了。p3224和p3225死亡后，p3226，p3227就没有父进程了，这在操作系统是不被允许的，所以p3226，p3227的父进程就被置为p1了，p1是永远不会死亡的，至于为什么，这里先不介绍，留到“三、fork高阶知识”讲。<br>总结一下，这个程序执行的流程如下：</p><p><img src="http://files.jb51.net/file_images/article/201606/2016622152338182.gif?2016522152421" alt="2016622152338182.gif (492×265)"></p></blockquote></blockquote><p><a href="http://www.jb51.net/article/87163.htm" target="_blank" rel="noopener">参考资料</a></p><h3 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><blockquote><p>主要功能如下：</p><p><strong>选择占有处理机的进程</strong></p><p>进程调度的主要功能是按照一定的策略选择—个处于<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">就绪状态</a>的进程，使其获得<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>执行。根据不同的系统设计目的，有各种各样的选择策略，例如<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E5%BC%80%E9%94%80" target="_blank" rel="noopener">系统开销</a>较少的静态优先数调度法，适合于<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">分时系统</a>的轮转法(Round RoLin)和多级互馈轮转法(Round Robin with Multip1e feedback)等。这些选择策略决定了调度算法的性能。</p><p><strong>进行进程上下文切换</strong></p><p>—个进程的上下文(context)包括进程的状态、有关变量和<a href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">数据结构</a>的值、机器<a href="https://baike.baidu.com/item/%E5%AF%84%E5%AD%98%E5%99%A8" target="_blank" rel="noopener">寄存器</a>的值和PCB以及有关程序、数据等。一个进程的执行是在进程的上下文中执行。当正在执行的进程由于某种原因要让出<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>时，系统要做<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87" target="_blank" rel="noopener">进程上下文</a>切换，以使另一个进程得以执行。当进行上下文切换时点统要首先检查是否允许做上下文切换(在有些情况下，上下文切换是不允许的，例如系统正在执行某个不允许中断的原语时)。然后，系统要保留有关被切换进程的足够信息，以便以后切换回该进程时，顺利恢复该进程的执行。在系统保留了CPU现场之后，调度程序选择一个新的处于<a href="https://baike.baidu.com/item/%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81" target="_blank" rel="noopener">就绪状态</a>的进程、并装配该进程的上下文，使CPU的控制权掌握在被选中进程手中。</p></blockquote><h4 id="调度策略"><a href="#调度策略" class="headerlink" title="调度策略"></a>调度策略</h4><blockquote><ol><li><p>先进先出算法</p><blockquote><p>算法总是把<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>分配给最先进入就绪队列的进程，一个进程一旦分得处理机，便一直执行下去，直到该进程完成或阻塞时，才释放处理机。</p><p>例如，有三个进程P1、P2和P3先后进入就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>，它们的执行期分别是21、6和3个单位时间，</p><p>执行情况如下图：</p><p>对于P1、P2、P3的<a href="https://baike.baidu.com/item/%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">周转时间</a>为21、27、30，平均周转时间为26。</p><p>可见，FIFO算法服务质量不佳，容易引起作业用户不满，常作为一种辅助<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">调度算法</a>。</p></blockquote></li><li><p>短进程优先算法</p><blockquote><p>最短CPU运行期优先<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">调度算法</a>(SCBF–Shortest CPU Burst First)</p><p>该算法从就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>中选出下一个“CPU执行期最短”的进程，为之分配<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>。</p><p>例如，在就绪<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>中有四个进程P1、P2、P3和P4，它们的下一个执行期分别是16、12、4和3个单位时间，执行情况如下图：</p><p>P1、P2、P3和P4的<a href="https://baike.baidu.com/item/%E5%91%A8%E8%BD%AC%E6%97%B6%E9%97%B4" target="_blank" rel="noopener">周转时间</a>分别为35、19、7、3，平均周转时间为16。</p><p>该算法虽可获得较好的调度性能，但难以准确地知道下一个CPU执行期，而只能根据每一个进程的执行历史来预测。</p></blockquote></li><li><p>轮转算法</p><blockquote><p>前几种算法主要用于<a href="https://baike.baidu.com/item/%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">批处理系统</a>中，不能作为<a href="https://baike.baidu.com/item/%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener">分时系统</a>中的主<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener">调度算法</a>，在分时系统中，都采用<a href="https://baike.baidu.com/item/%E6%97%B6%E9%97%B4%E7%89%87%E8%BD%AE%E8%BD%AC" target="_blank" rel="noopener">时间片轮转</a>法。</p><p>简单轮转法：系统将所有就绪进程按FIFO规则排队，按一定的时间间隔把<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>分配给队列中的进程。这样，就绪队列中所有进程均可获得一个时间片的<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA" target="_blank" rel="noopener">处理机</a>而运行。</p><p>多级<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>方法：将系统中所有进程分成若干类，每类为一级。</p></blockquote></li><li><p>多级反馈队列</p><blockquote><p>多级反馈<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97" target="_blank" rel="noopener">队列</a>方式是在系统中设置多个就绪队列，并赋予各队列以不同的优先权。</p></blockquote></li></ol></blockquote><p>###进程直接的切换</p><blockquote><p>在linux下，fg和bg命令是进程的前后调度命令，即将指定号码（非进程号）的命令进程放到前台或者后台运行。比如一个需要长时间的运行命令，我们就希望把它放入到后台，这样就不会阻塞当前的操作；而一些服务器的命令进程我们则希望能把它们长期的运行在后台。</p><p>ctrl+c 终止并退出前台命令的执行，回到shell。</p><p>ctrl+z 暂停前台命令的执行，将进程放入后台，回到shell。</p><p>jobs 查看当前在后台执行的命令，可以查看命令进程的号码。</p><p>&amp; 运行命令时，在命令末尾加上&amp;命令在后台执行。</p><p>fg N 将命令进程号码为N的命令进程放到前台执行，同%N。</p><p>bg N将命令进程号码为N的命令放到后台执行。</p></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>###死锁</p><p><strong>定义</strong> </p><blockquote><p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p></blockquote><p><strong>产生死锁的条件</strong></p><blockquote><p><strong>1</strong>）互斥条件：**指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。</p><p><strong>2**</strong>）请求和保持条件：**指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</p><p><strong>3**</strong>）不剥夺条件：**指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</p><p><strong>4**</strong>）环路等待条件：**指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。</p></blockquote><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h3><blockquote><p>Linux系统的shell相当于操作系统的“一层外壳”，它是命令语言解释器，它为用户提供了使用操作系统的接口，它不属于内核，而是在内核之外以用户态方式运行。它的基本功能是解释并执行用户打入的各种命令，实现用户与Linux内核的接口。</p></blockquote><h3 id="shell工作原理"><a href="#shell工作原理" class="headerlink" title="shell工作原理"></a>shell工作原理</h3><blockquote><ol><li>首先，检查用户输入的命令是否是内部命令，如果不是在检查是否是一个应用程序；</li><li>shell在搜索路径或者环境变量中寻找这些应用程序；</li><li>如果键入命令不是一个内部命令并且没有在搜索路径中查找到可执行文件，那么将会显示一条错误信息；</li><li>如果能够成功找到可执行文件，那么该内部命令或者应用程序将会被分解为系统调用传给Linux内核，然后内核在完成相应的工作；</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    主要介绍了关于进程及其相关的知识，更详细内容还需看书。感觉linux进程很深奥，很有意思。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shangrila-kun.github.io/categories/linux/"/>
    
    
      <category term="进程、线程" scheme="https://shangrila-kun.github.io/tags/%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>操作系统的介绍</title>
    <link href="https://shangrila-kun.github.io/2018/03/31/20180331-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BB%8B%E4%BB%8B%E7%BB%8D/"/>
    <id>https://shangrila-kun.github.io/2018/03/31/20180331-操作系统的介介绍/</id>
    <published>2018-03-31T06:25:53.000Z</published>
    <updated>2018-03-31T06:28:03.933Z</updated>
    
    <content type="html"><![CDATA[<p>​    一些基本的操作系统知识，主要谈了下操作系统的主要功能，进化史、linux系统特点、内核、版本号等一些基本知识点。</p><a id="more"></a><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><blockquote><p>操作系统（Operating System，简称OS）是管理和控制计算机硬件与软件资源的计算机程序，是直接运行在“裸机”上的最基本的系统软件，任何其他软件都必须在操作系统的支持下才能运行。</p></blockquote><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><blockquote><p><strong>进程管理</strong> 、<strong>内存管理</strong>、<strong>文件系统</strong>、<strong>网络通讯</strong> 、<strong>安全机制</strong>、<strong>用户界面</strong>、<strong>驱动程序</strong>。</p></blockquote><h3 id="操作系统的历史"><a href="#操作系统的历史" class="headerlink" title="操作系统的历史"></a>操作系统的历史</h3><p><strong>早期的操作系统</strong></p><blockquote><p>最初的电脑并没有操作系统，人们通过各种操作按钮来控制计算机，后来出现了汇编语言，操作人员通过有孔的纸带将程序输入电脑进行编译。这些将语言内置的电脑只能由操作人员自己编写程序来运行，不利于设备、程序的共用。为了解决这种问题，就出现了操作系统，这样就很好实现了程序的共用，以及对计算机硬件资源的管理。<br>　　随着计算技术和大规模集成电路的发展，微型计算机迅速发展起来。从20世纪70年代中期开始出现了计算机操作系统。1976年，美国DIGITAL RESEARCH软件公司研制出8位的CP/M操作系统。这个系统允许用户通过控制台的键盘对系统进行控制和管理，其主要功能是对文件信息进行管理，以实现硬盘文件或其他设备文件的自动存取。此后出现的一些8位操作系统多采用CP/M结构。</p></blockquote><p><strong>DOS操作系统</strong></p><blockquote><p>最初的电脑并没有操作系统，人们通过各种操作按钮来控制计算机，后来出现了汇编语言，操作人员通过有孔的纸带将程序输入电脑进行编译。这些将语言内置的电脑只能由操作人员自己编写程序来运行，不利于设备、程序的共用。为了解决这种问题，就出现了操作系统，这样就很好实现了程序的共用，以及对计算机硬件资源的管理。<br>　　随着计算技术和大规模集成电路的发展，微型计算机迅速发展起来。从20世纪70年代中期开始出现了计算机操作系统。1976年，美国DIGITAL RESEARCH软件公司研制出8位的CP/M操作系统。这个系统允许用户通过控制台的键盘对系统进行控制和管理，其主要功能是对文件信息进行管理，以实现硬盘文件或其他设备文件的自动存取。此后出现的一些8位操作系统多采用CP/M结构。</p></blockquote><p><strong>操作系统新时代</strong></p><blockquote><p>计算机操作系统发展的第二个阶段是多用户多道作业和分时系统。其典型代表有UNIX、XENIX、OS/2以及Windows操作系统。分时的多用户、多任务、树形结构的文件系统以及重定向和管道是UNIX的三大特点。</p></blockquote><h2 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h2><h3 id="操作系统在计算机系统中的地位"><a href="#操作系统在计算机系统中的地位" class="headerlink" title="操作系统在计算机系统中的地位"></a>操作系统在计算机系统中的地位</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; 操作系统在计算机系统中占据着一个非常重要的地位，它不仅是硬件与所有其他软件之间的接口，而且任何数字电子计算机都必须在其硬件平台上加载相应的操作系统之后，才能构成一个可以协调运转的计算机系统。只有在操作系统的指挥控制下，各种计算机资源才能被分配给用户使用。也只有在操作系统的支撑下，其他系统软件如各类编译系统、程序库和运行支持环境才得以取得运行条件。没有操作系统，任何应用软件都无法运行。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="批处理系统、分时系统和实时系统各有什么特点"><a href="#批处理系统、分时系统和实时系统各有什么特点" class="headerlink" title="批处理系统、分时系统和实时系统各有什么特点"></a>批处理系统、分时系统和实时系统各有什么特点</h3><blockquote><p><strong>批处理系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; 特点：用户把要计算的问题、数据和作业说明书一起交给操作员，操作员将一批算题输入到计算机，然后由操作系统来控制执行。 </div><div class="line">&gt; 适用方面：计算量大、不需要和用户交互的大型作业。</div><div class="line">&gt;</div></pre></td></tr></table></figure><p><strong>分时系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; (1)同时性。若干个终端用户可同时使用什算机；（2）独立性。用户彼此独立，互下干扰；(3)及时性。用户的请求能在较短时间内得到响应；（4）交互性。用户能进行人-机对话，联机地调试程序，以交互方式工作。 </div><div class="line">&gt; 适用方面：交互性强的多用户系统。 </div><div class="line">&gt;</div></pre></td></tr></table></figure><p><strong>实时系统</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; 事件驱动，具有实时性。</div><div class="line">&gt; 适用方面：较少有人为干预的监督和控制系统，例如，监督产品线，控制流水线生产的连续过程，监督病人的临界功能，监督和控制文通灯系统、监督和拄制实验室的实验以及监督军用飞机的状态等等。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="什么是GUN计划？Linux与GUN有什么关系"><a href="#什么是GUN计划？Linux与GUN有什么关系" class="headerlink" title="什么是GUN计划？Linux与GUN有什么关系"></a>什么是GUN计划？Linux与GUN有什么关系</h3><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; GUN计划发起于1984年，有著名的黑客Richard Stallman 提出的，GUN获得了自由软件基金会的支持，这也是GUN的主要资金来源，目的是为了建立免费的Unix系统，基本原则是源代码共享以及思想共享。</div><div class="line">&gt; GUN是“GUN&apos;s Not Unix”的递归缩写。</div><div class="line">&gt; Linux是基于Copyleft的软件模式进行发布的，其实Copyleft是Copyright相对立的新名称，是GUN项目制定的通用公共许可证，GPL是由自由软件基金会发行的用于计算机软件的协议证书，使用该证书的软件被称为自由软件，GPL保证了任何人都有权复制修改和发布新的源代码，并且规定不增加费用的情况下得到源代码，但你不能声明你做了原始工作或是由他人做的。</div><div class="line">&gt;</div><div class="line">&gt; Linux可以说是Unix的一个升级版的克隆体，Linux也是GUN计划中的一部分，和windows这类与专利权的操作系统不一样，Linux任然公开开放源代码并且得到不断地扩展。</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="linux系统有哪些特点"><a href="#linux系统有哪些特点" class="headerlink" title="linux系统有哪些特点"></a>linux系统有哪些特点</h3><blockquote><p><strong>一．开放性 </strong><br>​    是指系统遵循世界标准规范，特别是遵循开放系统互连（OSI）国际标准。凡遵循国际标准所开发的硬件和软件，都能彼此兼容，可方便地实现互连。<br><strong>二．多用户 </strong><br>​    是指系统资源可以被不同用户使用，每个用户对自己的资源（例如：文件、设备）有特定的权限，互不影响。Linux和Unix都具有多用户的特性。<br><strong>三．多任务 </strong><br>​    是现代计算机的最主要的一个特点。它是指计算机同时执行多个程序，而且各个程序的运行互相独立。Linux系统调度每一个进程平等地访问微处理器。由于CPU的处理速度非常快，其结果是，启动的应用程序看起来好像在并行运行。事实上，从处理器执行一个应用程序中的一组指令到Linux调度微处理器再次运行这个程序之间只有很短的时间延迟，用户是感觉不出来的。<br><strong>四．良好的用户界面 </strong><br>​    Linux向用户提供了两种界面：用户界面和系统调用。Linux的传统用户界面是基于文本的命令行界面，即shell，它既可以联机使用，又可存在文件上脱机使用。shell有很强的程序设计能力，用户可方便地用它编制程序，从而为用户扩充系统功能提供了更高级的手段。可编程Shell是指将多条命令组合在一起，形成一个Shell程序，这个程序可以单独运行，也可以与其他程序同时运行。 系统调用给用户提供编程时使用的界面。用户可以在编程时直接使用系统提供的系统调用命令。系统通过这个界面为用户程序提供低级、高效率的服务。Linux还为用户提供了图形用户界面。它利用鼠标、菜单、窗口、滚动条等设施，给用户呈现一个直观、易操作、交互性强的友好的图形化界面。<br><strong>五．设备独立性 </strong><br>​    设备独立性是指操作系统把所有外部设备统一当作成文件来看待，只要安装它们的驱动程序，任何用户都可以象使用文件一样，操纵、使用这些设备，而不必知道它们的具体存在形式。 具有设备独立性的操作系统，通过把每一个外围设备看作一个独立文件来简化增</p></blockquote><h3 id="linux系统由哪几部分组成？linux内核的功能是什么"><a href="#linux系统由哪几部分组成？linux内核的功能是什么" class="headerlink" title="linux系统由哪几部分组成？linux内核的功能是什么"></a>linux系统由哪几部分组成？linux内核的功能是什么</h3><blockquote><p>一般系统的组成由内核，shell(命令解释器)、应用程序等。</p><p>Linux系统一般有4个主要部分：<strong>内核、shell、文件系统和应用程序。内核、shell和文件系统一起形成了基本的操作系统结构，它们使得用户可以运行程序、管理文件并使用系统。</strong></p><p><strong>内核的功能</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; 内核是操作系统的核心，具有很多最基本功能，如虚拟内存、多任务、共享库、需求加载、可执行程序和TCP/IP网络功能。Linux内核的模块分为以下几个部分：存储管理、CPU和进程管理、文件系统、设备管理和驱动、网络通信、系统的初始化和系统调用等。</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote></blockquote><p>&gt;</p><blockquote><p><strong>Linux shell的功能</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; shell是系统的用户界面，提供了用户与内核进行交互操作的一种接口。它接收用户输入的命令并把它送入内核去执行，是一个命令解释器。另外，shell编程语言具有普通编程语言的很多特点，用这种编程语言编写的shell程序与其他应用程序具有同样的效果。</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote></blockquote><p>&gt;</p><blockquote><p><strong>Linux文件系统</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; 文件系统是文件存放在磁盘等存储设备上的组织方法。Linux系统能支持多种目前流行的文件系统，如EXT2、EXT3、FAT、FAT32、VFAT和ISO9660。</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote></blockquote><p>&gt;</p><blockquote><p><strong>Linux 应用程序</strong></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; &gt; 标准的Linux系统一般都有一套都有称为应用程序的程序集，它包括文本编辑器、编程语言、XWindow、办公套件、Internet工具和数据库等。</div><div class="line">&gt; &gt;</div></pre></td></tr></table></figure></blockquote></blockquote><h3 id="如何查看linux内核版本号和系统版本"><a href="#如何查看linux内核版本号和系统版本" class="headerlink" title="如何查看linux内核版本号和系统版本"></a>如何查看linux内核版本号和系统版本</h3><blockquote><p>查看linux内核版本命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;</span> cat /proc/version</div><div class="line"><span class="meta">&gt;</span></div><div class="line"><span class="meta">&gt;</span> Linux version 4.15.0-1.el7.elrepo.x86_64 (mockbuild@Build64R7) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-16) (GCC))ST 2018</div><div class="line"><span class="meta">&gt;</span></div><div class="line"><span class="meta">&gt;</span> uname -a</div><div class="line"><span class="meta">&gt;</span> Linux VM_250_91_centos 4.15.0-1.el7.elrepo.x86_64 #1 SMP Sun Jan 28 20:45:20 EST 2018 x86_64 x86_64 x86_64 GNU/Linux</div><div class="line"><span class="meta">&gt;</span></div><div class="line"><span class="meta">&gt;</span> //可以看出，linux的内核版本号是4.15.0   用的是红帽 4.8.5系列。 系统安装时间是218年1月28号 星期天 20点45分20秒。</div><div class="line"><span class="meta">&gt;</span></div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    一些基本的操作系统知识，主要谈了下操作系统的主要功能，进化史、linux系统特点、内核、版本号等一些基本知识点。&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shangrila-kun.github.io/categories/linux/"/>
    
    
      <category term="操作系统介绍" scheme="https://shangrila-kun.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>搭建java web框架架</title>
    <link href="https://shangrila-kun.github.io/2018/03/24/20180324%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BAjava-web%E6%A1%86%E6%9E%B6%E6%9E%B6/"/>
    <id>https://shangrila-kun.github.io/2018/03/24/20180324自己搭建java-web框架架/</id>
    <published>2018-03-24T14:07:23.000Z</published>
    <updated>2018-05-04T00:59:46.675Z</updated>
    
    <content type="html"><![CDATA[<p>​    本章主要介绍maven项目、pom.xml、WEB服务器、什么是servlet、Tomcat工作原理。</p><a id="more"></a><h2 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h2><blockquote><p><a href="https://blog.csdn.net/zzy1078689276/article/details/78732183" target="_blank" rel="noopener">创建教程</a></p></blockquote><h2 id="web-xml讲解"><a href="#web-xml讲解" class="headerlink" title="web.xml讲解"></a>web.xml讲解</h2><blockquote><p><a href="https://www.cnblogs.com/ClassNotFoundException/p/6641867.html" target="_blank" rel="noopener">web.xml配置详细</a></p></blockquote><p>##部署Maven工程到Tomcat</p><blockquote><p><a href="https://blog.csdn.net/li_steve/article/details/72812084" target="_blank" rel="noopener">Intellij Idea2016部署Maven工程到Tomcat</a></p></blockquote><p>##pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></div><div class="line">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></div><div class="line">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.apqts<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>chapter1<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--设置maven使用UTF-8进行编码--&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--统一源代码与编译输出的JDK版本--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Compile--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Test--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-surefire-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.20<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">skipTests</span>&gt;</span>true<span class="tag">&lt;/<span class="name">skipTests</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">            <span class="comment">&lt;!--Tomcat--&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat7-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">                <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line">                    <span class="tag">&lt;<span class="name">path</span>&gt;</span>/$&#123;project.artifactId&#125;<span class="tag">&lt;/<span class="name">path</span>&gt;</span></div><div class="line">                <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div><div class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!--打包设置--&gt;</span><span class="comment">&lt;!--如果某些依赖只是运行时需要，但无须参与打编译，可将scope设置为runtime--&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">groupId</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line"></div><div class="line">                <span class="comment">&lt;!-- Servlet -api --&gt;</span><span class="comment">&lt;!--如果某些依赖只是运行时需要，但无须参与编译，可将scope设置为provided--&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span> provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span> javax.servlet<span class="tag">&lt;/<span class="name">groupId</span> &gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span> jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span> provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h2><h3 id="Http-Server"><a href="#Http-Server" class="headerlink" title="Http Server"></a>Http Server</h3><blockquote><p><strong>运行在服务器之上，绑定服务器的IP地址并监听某一个tcp端口来接收并处理HTTP请求</strong>，浏览器就能够通过HTTP协议来获取服务器上的网页（HTML格式）、文档（PDF格式）、音频（MP4格式）、视频（MOV格式）等等资源。<strong>一个HTTP Server关心的是HTTP协议层面的传输和访问控制</strong>。</p></blockquote><h4 id="Apache-HTTP服务器"><a href="#Apache-HTTP服务器" class="headerlink" title="Apache HTTP服务器"></a>Apache HTTP服务器</h4><blockquote><p>Apache支持模块多，性能稳定，Apache本身是静态解析，适合静态HTML、图片等，但可以通过扩展脚本、模块等支持动态页面等。</p><p>对Java，需要Tomcat在Apache后台支撑，将Java请求由Apache转发给Tomcat处理。</p></blockquote><h4 id="Nginx-HTTP服务器"><a href="#Nginx-HTTP服务器" class="headerlink" title="Nginx HTTP服务器"></a>Nginx HTTP服务器</h4><blockquote><p>Nginx是一个高性能的HTTP和反向代理服务器，同时也是一个IMAP/POP3/SMTP代理服务器。</p><p><strong>其特点是占有内存少，并发能力强</strong>。Nginx代码完全用C语言从头写成。</p><p><strong>具有很高的稳定性</strong>。其它HTTP服务器，当遇到访问的峰值，或者有人恶意发起慢速连接时，也很可能会导致服务器物理内存耗尽频繁交换，失去响应，只能重启服务器。例如当前apache一旦上到200个以上进程，web响应速度就明显非常缓慢了。</p><p><strong>而Nginx采取了分阶段资源分配技术，使得它的CPU与内存占用率非常低</strong>。Nginx官方表示保持10000个没有活动的连接，它只占2.5M内存，所以类似DOS这样的攻击对nginx来说基本上是毫无用处的。<strong>就稳定性而言</strong>，Nginx比Lighthttpd更胜一筹。</p></blockquote><h4 id="Nginx与Apache比较"><a href="#Nginx与Apache比较" class="headerlink" title="Nginx与Apache比较"></a>Nginx与Apache比较</h4><blockquote><ol><li><strong>轻量级</strong>，同样启动WEB服务，比Apache占用更少的内存以及资源；</li><li><strong>抗并发性能高</strong>，核心区别在于<strong>Apache是同步多进程模型，一个连接对应一个进程</strong>。<strong>Nginx是异步的，多个连接（万级别）可以对应一个进程</strong>；</li><li><strong>Nginx模块较少，配置简单</strong>，所以Nginx可以将资源用在数据处理以及进程上面，Apache模块较多比较全，相对稳定，但在内存资源上消耗比较大；</li><li><strong>Nginx可以在不间断的情况下进行软件版本的升级</strong>；</li><li><strong>Nginx处理静态页面性能比apache高3倍多</strong>；</li></ol></blockquote><p>选择高并发高性能就选择Nginx，如果要稳定，选择Apache，主要根据服务器要面临的需求而定。</p><h3 id="Application-Server"><a href="#Application-Server" class="headerlink" title="Application Server"></a>Application Server</h3><blockquote><p>与HTTP Server相比，Application Server能够动态的生成资源并返回到客户端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; |- Application Server</div><div class="line">&gt;     |- Tomcat</div><div class="line">&gt;     |- Jetty</div><div class="line">&gt;</div></pre></td></tr></table></figure><p><strong>Servlet Container:为了支持Servlet</strong>。<strong>Web服务器软件处理一般请求，并把Servlet调用传递给“容器”来处理。</strong></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2062729-8cf5a891988e314f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>HTTP Server 与 Application Server</p><p><strong>Tomcat运行在JVM之上，它和HTTP服务器一样，绑定IP地址并监听TCP端口，同时还包含以下指责：</strong></p><blockquote><ol><li>管理Servlet程序的生命周期；</li><li>将URL映射到指定的Servlet进行处理；</li><li>与Servlet程序合作处理HTTP请求——根据HTTP请求生成HttpServletRequest/Response对象并传递给Servlet进行处理，将Servlet中的HttpServletResponse对象生成的内容返回给浏览器</li></ol></blockquote></blockquote><h4 id="Servlet的工作模式"><a href="#Servlet的工作模式" class="headerlink" title="Servlet的工作模式"></a>Servlet的工作模式</h4><p>按照工作模式的不同，servlet的工作模式可以分为三类。</p><blockquote><p><strong>独立运行的Servlet容器</strong></p><blockquote><p>在这种模式下，<strong>Servlet容器作为构成Web服务器的一部分而存在</strong>。当使用基于Java的Web服务器时，就属于这种情况。<strong>这种方式是Tomcat的默认模式</strong>，然而大多数Web服务器并不是基于Java的，所以就产生了下面的两种其他类型。</p></blockquote><p><strong>内置的Servlet容器</strong></p><blockquote><p><strong>Servlet容器由Web服务器插件和Java容器两部分组成</strong>。采用这种方式时，<strong>Web服务器插件需要在某个Web服务器内部地址空间中打开一个JVM（Java虚拟机），在此JVM上加载Java容器并运行Servlet</strong>。如果客户端调用Servlet，Web服务器插件首先获得此请求的控制并将它传递（使用JNI技术）给Java容器，然后Java容器把此请求交给Servlet来处理。这种方式运行速度较快，并且能够提供良好的性能，适用于单进程、多线程服务器，但是在伸缩性方面存在不足。</p></blockquote><p><strong>外置的Servlet容器</strong></p><blockquote><p>采用这种方式时，<strong>Servlet容器运行在Web服务器外部地址空间</strong>。先由<strong>Web服务器插件在某个Web服务器外部地址空间打开一个JVM（Java虚拟机），然后加载Java容器来运行Servlet</strong>。Web服务器插件和JVM之间使用IPC（进程间通信）机制（通常是TCP/IPSockets）。如果客户端调用Servlet，Web服务器插件首先获得此请求的控制并将它传递（使用IPC技术）给Java容器，然后Java容器把此请求交给Servlet来处理。这种方式对客户端请求的处理速度不如内置Servlet那样快，但是在其他方面（如可伸缩性、稳定性等）具有优势。</p></blockquote><p>Tomcat属于Servlet容器，其工作模式也分为上述3种，<strong>所以Tomcat既可被用作独立运行的Servlet引擎（便于开发和调试），又可作为一个需要增强功能的Web服务器（如当前的Apache、IIS和Netscape服务器）插件</strong>。在配置Tomcat之前，就需要确定采用哪种工作模式，工作模式（1）比较简单，直接安装Tomcat即可，工作模式（2）和（3）有些复杂，除了安装Tomcat、Web服务器之外，还需要安装连接两者的中间连接件。</p></blockquote><h4 id="Apache与Tomcat整合使用"><a href="#Apache与Tomcat整合使用" class="headerlink" title="Apache与Tomcat整合使用"></a>Apache与Tomcat整合使用</h4><blockquote><p>虽然Tomcat也可以认为是HTTP服务器，但通常它仍然会和Apache/Nginx配合在一起使用：</p><blockquote><ol><li><strong>动静态资源分离</strong>——运用Nginx的反向代理功能分发请求：所有动态资源的请求交给Tomcat，而静态资源的请求（例如图片、视频、CSS、JavaScript文件等）则直接由Nginx返回到浏览器，这样能大大减轻Tomcat的压力；</li><li><strong>负载均衡</strong>——当业务压力增大时，可能一个Tomcat的实例不足以处理，那么这时可以启动多个Tomcat实例进行水平扩展，而Nginx的负载均衡功能可以把请求通过算法分发到各个不同的实例进行处理；</li></ol></blockquote><p><strong>整合的好处：</strong></p><blockquote><ol><li><ol><li>如果客户端请求的是静态页面，则只需要Apache服务器响应请求。</li><li>如果客户端请求动态页面，则是Tomcat服务器响应请求。</li><li>因为JSP是服务器端解释代码的，这样整合就可以减少Tomcat的服务开销。</li></ol></li></ol></blockquote></blockquote><h2 id="什么是servlet"><a href="#什么是servlet" class="headerlink" title="什么是servlet"></a>什么是servlet</h2><blockquote><p><strong>Servlet对每个请求都是单独启动一个线程，而不是进程。</strong>降低系统里的进程数量，提高系统的并发处理能力。另外因为Java Servlet是运行在虚拟机之上的，也就解决了跨平台问题。</p></blockquote><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><blockquote><p>作为一名专业编程人员，您碰到的大多数 Java servlet 都是为响应 Web 应用程序上下文中的 HTTP 请求而设计的。<strong>因此，javax.servlet 和 javax.servlet.http 包中特定于 HTTP 的类是您应该关心的。</strong>对于Servlet容器(Tomcat)与HttpServlet是怎样进行交互的呢，看下类图：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2062729-fa39524956cd25e0.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>​    Servlet的框架是由两个Java包组成的：javax.servlet与javax.servlet.http。在javax.servlet包中定义了所有的Servlet类都必须实现或者扩展的通用接口和类。<strong>在javax.servlet.http包中定义了采用Http协议通信的HttpServlet类</strong>。Servlet的框架的核心是javax.servlet.Servlet接口，所有的Servlet都必须实现这个接口。<strong>在Servlet接口中定义了5个方法，其中3个方法代表了Servlet的生命周期：</strong></p><blockquote><ol><li>init(ServletConfig)方法：负责初始化Servlet对象，在Servlet的生命周期中，该方法执行一次；该方法执行在单线程的环境下，因此开发者不用考虑线程安全的问题；</li><li>service(ServletRequest req,ServletResponse res)方法：负责响应客户的请求；为了提高效率，Servlet规范要求一个Servlet实例必须能够同时服务于多个客户端请求，即service()方法运行在多线程的环境下，Servlet开发者必须保证该方法的线程安全性；</li><li>destroy()方法：当Servlet对象退出生命周期时，负责释放占用的资源；</li></ol></blockquote><p>​    在创建一个 Java servlet 时，一般需要子类 HttpServlet。该类中的方法允许您访问请求和响应包装器（wrapper），您可以用这个包装器来处理请求和创建响应。<strong>大多数程序员都知道Servlet的生命周期，简单的概括这就分为四步：</strong></p><blockquote><p>Servlet类加载—&gt;实例化—&gt;服务—&gt;销毁；</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2062729-7f3b114e0350a670.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p><strong>创建Servlet对象的时机：</strong></p><ol><li><strong>默认情况下，在Servlet容器启动后：</strong>客户首次向Servlet发出请求，Servlet容器会判断内存中是否存在指定的Servlet对象，如果没有则创建它，然后根据客户的请求创建HttpRequest、HttpResponse对象，从而调用Servlet对象的service方法；</li><li><strong>Servlet容器启动时：</strong>当web.xml文件中如果<servlet>元素中指定了<load-on-startup>子元素时，Servlet容器在启动web服务器时，将按照顺序创建并初始化Servlet对象；</load-on-startup></servlet></li><li><strong>Servlet的类文件被更新后，重新创建Servlet。</strong>Servlet容器在启动时自动创建Servlet，这是由在web.xml文件中为Servlet设置的<load-on-startup>属性决定的。从中我们也能看到同一个类型的Servlet对象在Servlet容器中以单例的形式存在；</load-on-startup></li></ol><blockquote><p>注意：在web.xml文件中，某些Servlet只有<code>&lt;serlvet&gt;</code>元素，没有<code>&lt;servlet-mapping&gt;</code>元素，这样我们无法通过url的方式访问这些Servlet，这种Servlet通常会在<code>&lt;servlet&gt;</code>元素中配置一个<code>&lt;load-on-startup&gt;</code>子元素，让容器在启动的时候自动加载这些Servlet并调用init(ServletConfig config)方法来初始化该Servlet。其中方法参数config中包含了Servlet的配置信息，比如初始化参数，该对象由服务器创建。</p></blockquote><p><strong>销毁Servlet对象的时机：</strong></p><blockquote><p>Servlet容器停止或者重新启动：Servlet容器调用Servlet对象的destroy方法来释放资源。以上所讲的就是Servlet对象的生命周期。那么Servlet容器如何知道创建哪一个Servlet对象？Servlet对象如何配置？实际上这些信息是通过读取web.xml配置文件来实现的。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Servlet对象的名称 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 创建Servlet对象所要调用的类 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.apache.struts.action.ActionServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 参数名称 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>config<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="comment">&lt;!-- 参数值 --&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/struts-config.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>detail<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>debug<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- Servlet容器启动时加载Servlet对象的顺序 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>2<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 要与servlet中的servlet-name配置节内容对应 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>action<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></div><div class="line">    <span class="comment">&lt;!-- 客户访问的Servlet的相对URL路径 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.do<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>当Servlet容器启动的时候读取<servlet>配置节信息，根据<servlet-class>配置节信息创建Servlet对象，同时根据<init-param>配置节信息创建HttpServletConfig对象，然后执行Servlet对象的init方法，并且根据<load-on-startup>配置节信息来决定创建Servlet对象的顺序，如果此配置节信息为负数或者没有配置，那么在Servlet容器启动时，将不加载此Servlet对象。当客户访问Servlet容器时，Servlet容器根据客户访问的URL地址，通过<servlet-mapping>配置节中的<url-pattern>配置节信息找到指定的Servlet对象，并调用此Servlet对象的service方法。</url-pattern></servlet-mapping></load-on-startup></init-param></servlet-class></servlet></p><p>在整个Servlet的生命周期过程中，<strong>创建Servlet实例、调用实例的init()和destroy()方法都只进行一次</strong>，当初始化完成后，Servlet容器会将该实例保存在内存中，通过调用它的service()方法，为接收到的请求服务。下面给出Servlet整个生命周期过程的UML序列图，如图所示：</p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/2062729-89d2fd9e92040ff9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>如果需要让Servlet容器在启动时即加载Servlet，可以在web.xml文件中配置<load-on-startup>元素。</load-on-startup></p></blockquote><p>###Servlet工作原理</p><p><img src="https://upload-images.jianshu.io/upload_images/2062729-14290e2fa96e4d4a.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><p>Servlet工作原理时序图</p><blockquote><ol><li>Web Client 向Servlet容器（Tomcat）发出Http请求；</li><li>Servlet容器接收Web Client的请求；</li><li>Servlet容器创建一个HttpRequest对象，将Web Client请求的信息封装到这个对象中；</li><li>Servlet容器创建一个HttpResponse对象；</li><li>Servlet容器调用HttpServlet对象的service方法，把HttpRequest对象与HttpResponse对象作为参数传给 HttpServlet对象；</li><li>HttpServlet调用HttpRequest对象的有关方法，获取Http请求信息；</li><li>HttpServlet调用HttpResponse对象的有关方法，生成响应数据；</li><li>Servlet容器把HttpServlet的响应结果传给Web Client；</li></ol></blockquote><h3 id="Servlet的四种方式请求方式（待写）"><a href="#Servlet的四种方式请求方式（待写）" class="headerlink" title="Servlet的四种方式请求方式（待写）"></a>Servlet的四种方式请求方式（待写）</h3><blockquote><p>get、post、put、delete。</p></blockquote><h2 id="Tomcat工作原理"><a href="#Tomcat工作原理" class="headerlink" title="Tomcat工作原理"></a>Tomcat工作原理</h2><p>Tomcat 的结构很复杂，但是 Tomcat 也非常的模块化，找到了 Tomcat 最核心的模块，您就抓住了 Tomcat 的“七寸”。下面是 Tomcat 的总体结构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2062729-15bb966deef614f5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><blockquote><p>从上图可以看出Tomcat的核心是两个组件：<strong>连接器（Connector）和容器（Container）</strong>。Connector组件是负责生成请求对象和响应对象的，Tomcat默认的是HttpConnector，负责根据收到的Http请求报文生成Request对象和Response对象，并把这两个对象传递给Container，然后根据Response中的内容生成相应的HTTP报文。</p><p><strong>Container是容器的父接口，所有子容器都必须实现这个接口，简单来说就是服务器部署的项目是运行在Container中的</strong>。Container里面的项目获取到Connector传递过来对应的的Request对象和Response对象进行相应的操作。</p><p><strong>Connector可以根据不同的设计和应用场景进行替换</strong>。一个Container可以选择对应多个Connector。<strong>多个Connector和一个Container就形成了一个Service，有了Service就可以对外提供服务了</strong>。</p><p><strong>Tomcat要为一个Servlet的请求提供服务，需要做三件事：</strong></p><blockquote><ol><li>创建一个request对象并填充那些有可能被所引用的Servlet使用的信息，如参数，头部、cookies、查询字符串等。一个request对象就是javax.servlet.ServletRequest或javax.servlet.http.ServletRequest接口的一个实例。</li><li>创建一个response对象，所引用的servlet使用它来给客户端发送响应。一个response对象是javax.servlet.ServletResponse或javax.servlet.http.ServletResponse接口的一个实例。</li><li>调用servlet的service方法，并传入request和response对象。这里servlet会从request对象取值，给response写值。</li><li>根据servlet返回的response生成相应的HTTP响应报文</li></ol><p>既然我们已经抓到Tomcat的“七寸”，两个核心组件：<strong>连接器（Connector）和容器（Container）</strong>，那这样从连接器（Connector）入手，来看下Tomcat处理HTTP请求的流程。</p><p>很多开源应用服务器都是集成tomcat作为web container的，而且对于tomcat的servlet container这部分代码很少改动。这样，<strong>这些应用服务器的性能基本上就取决于Tomcat处理HTTP请求的connector模块的性能</strong>。</p></blockquote></blockquote><h3 id="Connector种类"><a href="#Connector种类" class="headerlink" title="Connector种类"></a>Connector种类</h3><p>Tomcat源码中与connector相关的类位于org.apache.coyote包中，Connector分为以下几类：</p><blockquote><p><strong>Http Connector，基于HTTP协议，负责建立HTTP连接</strong>。它又分为BIO Http Connector与NIO Http Connector两种，后者提供非阻塞IO与长连接Comet支持。</p><p>AJP Connector，基于AJP协议，<strong>AJP是专门设计用来为tomcat与http服务器之间通信专门定制的协议</strong>，能提供较高的通信速度和效率。如与Apache服务器集成时，采用这个协议。</p><p>APR HTTP Connector，用C实现，通过JNI调用的。<strong>主要提升对静态资源（如HTML、图片、CSS、JS等）的访问性能</strong>。现在这个库已独立出来可用在任何项目中。Tomcat在配置APR之后性能非常强劲。</p></blockquote><h3 id="Connector配置"><a href="#Connector配置" class="headerlink" title="Connector配置"></a>Connector配置</h3><p>对Connector的配置位于conf/server.xml文件中。</p><p>BIO HTTP/1.1 Connector配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;Connector port=”8080” protocol=”HTTP/1.1” maxThreads=”150” </div><div class="line">    connectionTimeout=”20000” redirectPort=”8443” /&gt;</div></pre></td></tr></table></figure><p>其它一些重要属性如下：</p><blockquote><p>acceptCount : 接受连接request的最大连接数目，默认值是10；</p><p>address : 绑定IP地址，如果不绑定，默认将绑定任何IP地址；</p><p>allowTrace : 如果是true,将允许TRACE HTTP方法；</p><p>compressibleMimeTypes : 各个mimeType, 以逗号分隔，如text/html,text/xml；</p><p>compression : 如果带宽有限的话，可以用GZIP压缩；</p><p>connectionTimeout : 超时时间，默认为60000ms (60s)；</p><p>maxKeepAliveRequest : 默认值是100；</p><p>maxThreads : 处理请求的Connector的线程数目，默认值为200；</p></blockquote><p>###Tomcat架构模块</p><p><img src="https://upload-images.jianshu.io/upload_images/2062729-3da95ca10cc5d75f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="img"></p><h3 id="Tomcat运行流程"><a href="#Tomcat运行流程" class="headerlink" title="Tomcat运行流程"></a>Tomcat运行流程</h3><p><img src="https://upload-images.jianshu.io/upload_images/2062729-fefd9142bc563fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240/format/jpg" alt="img"></p><p><strong>假设来自客户的请求为：<a href="http://localhost:8080/test/index.jsp" target="_blank" rel="noopener">http://localhost:8080/test/index.jsp</a></strong></p><blockquote><ol><li>请求被发送到本机端口8080，被在那里侦听的Coyote HTTP/1.1 Connector获得；</li><li>Connector把该请求交给它所在的Service的Engine来处理，并等待Engine的回应；</li><li>Engine获得请求localhost:8080/test/index.jsp，匹配它所有虚拟主机Host；</li><li>Engine匹配到名为localhost的Host（即使匹配不到也把请求交给该Host处理，因为该Host被定义为该Engine的默认主机）；</li><li>localhost Host获得请求/test/index.jsp，匹配它所拥有的所有Context；</li><li>Host匹配到路径为/test的Context（如果匹配不到就把该请求交给路径名为””的Context去处理）；</li><li>path=”/test”的Context获得请求/index.jsp，在它的mapping table中寻找对应的servlet；</li><li>Context匹配到URL PATTERN为*.jsp的servlet，对应于JspServlet类；</li><li>构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用JspServlet的doGet或doPost方法；</li><li>Context把执行完了之后的HttpServletResponse对象返回给Host；</li><li>Host把HttpServletResponse对象返回给Engine；</li><li>Engine把HttpServletResponse对象返回给Connector；</li><li>Connector把HttpServletResponse对象返回给客户browser；</li></ol></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本章主要介绍maven项目、pom.xml、WEB服务器、什么是servlet、Tomcat工作原理。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://shangrila-kun.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="java web" scheme="https://shangrila-kun.github.io/tags/java-web/"/>
    
  </entry>
  
  <entry>
    <title>linux基本基本命令</title>
    <link href="https://shangrila-kun.github.io/2018/03/24/20180324linux%E5%9F%BA%E6%9C%AC%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <id>https://shangrila-kun.github.io/2018/03/24/20180324linux基本基本命令/</id>
    <published>2018-03-24T10:52:47.000Z</published>
    <updated>2018-03-24T11:23:08.116Z</updated>
    
    <content type="html"><![CDATA[<p>​    学号linux不是一件一蹴而就的事情，一定要坚持坚持再坚持。自己每每感觉学习linux是一个长期的过程，很耗时间，本文主要记载在学习中一些命令的使用及介绍，以供自己温故而知新。</p><a id="more"></a><h2 id="vim的使用技巧"><a href="#vim的使用技巧" class="headerlink" title="vim的使用技巧"></a>vim的使用技巧</h2><p><strong>编辑文档操作</strong></p><blockquote><p>x:删除光标当前字符<br>dd:删除一行<br>ndd:删除n行（n为数字）<br>d$删除光标至行尾。<br>u:撤销上一步操作，可以多次使用，如输入两个u，表示撤销2步。<br>rx:将当前光标字符替换为x<br>yy:复制当前行。<br>p:粘贴至当前行之后。<br>P：粘贴至当前行之前。<br>J:删除换行符，可以将两行合并为一行。<br>VIM查找与替换<br>/host,从上望下查。 /?关键词从下往上查。<br>：1,$s/xxx/yyy/ 将从第一行至尾行内的xxx替换成yyy。<br>：s/root/admin/ 将光标当前行中第一个出现root替换为admin<br>：s/root/admin/g 将当前行中所有的root替换为admin<br>：3,5 s/sbin/bin/g将3到5行之间的所有sbin替换为bin</p></blockquote><p><strong>vim光标操作</strong></p><blockquote><p>h:光标向左移动一位<br>j:光标向下移动一行（以回车为换行符）<br>k:光标向上移动一行。<br>l:光标向右移动一行。<br>gg:光标移动至文件首行。<br>G：光标移动至文件末尾。<br>nG:移动光标至n行。<br>^:光标移动至当前行的首字符。<br>$:光标移动至行前行的尾字符。<br>fx:光标移至当前行的下一个x字符处。<br>Fx:光标移至当前行的上一个x字符处。<br>W:光标向右移动一个单词。<br>nw：光标向右移动n个单词。<br>b:光标向左移动一个单词。<br>nb：光标向左移动n个单词。</p></blockquote><p><strong>vim保存与退出</strong></p><blockquote><p>：q! 不保存并 ：wq 保存并退出  ：x 保存并退出 ：w 保存<br>：w b.txt 另存为b.txt<br> :set ignorecase 查找时不区分大小写<br>vim多窗口编辑<br>：split可以同一个文档的不同行。Ctrl+w+j跳转至上面一个窗口<br>Ctrl+w+k跳转至下一个窗口。<br>：split second.txt 打开新的文件。</p></blockquote><h2 id="ps-aux-grep-xxx详解"><a href="#ps-aux-grep-xxx详解" class="headerlink" title="ps aux|grep xxx详解"></a>ps aux|grep xxx详解</h2><blockquote><p>对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程, 而ps命令（Process Status）就是最基本同时也是非常强大的进程查看命令.使用该命令 可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等.总之大部分信息都是可以通过执行该命令得到的。</p><p>ps 为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用 top 工具。</p><p>如果直接用ps命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p></blockquote><p><strong>grep</strong></p><blockquote><p>grep （global search regular expression(RE) and print out the line,全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> ps -aux|grep nginx</div><div class="line"> root     25001  0.0  0.0 122036  1460 ?        Sl   02:00   0:34 /usr/local/middleware/Git_NTP_APQTS_Code_Mid_MIS/LL/application/bin</div><div class="line">root     25003  2.8  8.1 3533580 316088 ?      Sl   02:00  29:34 /usr/local/java/jdk1.8.0_144/bin/java -Djava.util.logging.config.fi</div><div class="line">root     25272  0.0  0.0 122036  1456 ?        Sl   02:06   0:34 /usr/local/middleware/Git_NTP_APQTS_Code_Mid_MIS_Simp/AGP/application/bin</div></pre></td></tr></table></figure><blockquote><p>运行 ps aux 的到如下信息：</p><p>   ps aux</p><p>USER    PID   %CPU %MEM VSZ   RSS TTY    STAT   START TIME COMMAND</p><p>stat 中的参数意义如下：<br>   D 不可中断 Uninterruptible（usually IO）<br>   R 正在运行，或在队列中的进程<br>   S 处于休眠状态<br>   T 停止或被追踪<br>   Z 僵尸进程<br>   W 进入内存交换（从内核2.6开始无效）<br>   X   死掉的进程</p><p>&lt; 高优先级<br>n   低优先级<br>s   包含子进程</p><p>+位于后台的进程组</p></blockquote><h3 id="ps命令"><a href="#ps命令" class="headerlink" title="ps命令"></a>ps命令</h3><blockquote><p>ps命令</p><p>要对进程进行监测和控制,首先必须要了解当前进程的情况,也就是需要查看当前进程,而ps命令就是最基本同时也是非常强大的进程查看命令.使用该命令可以确定有哪些<strong>进程正在运行和运行的状态、进程是否结束、进程有没有僵尸、哪些进程占用了过多的资源等等</strong>.总之大部分信息都是可以通过执行该命令得到的.</p><p>ps命令最常用的还是用于监控后台进程的工作情况,因为后台进程是不和屏幕键盘这些标准输入/输出设备进行通信的,所以如果需要检测其情况,便可以使用ps命令了.</p><p> 1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。</p><p>2）ps -A 显示所有程序。</p><p>3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。</p><p>4）ps -e 此参数的效果和指定”A”参数相同。</p><p>5）ps e 列出程序时，显示每个程序所使用的环境变量。</p><p>6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。</p><p>7）ps -H 显示树状结构，表示程序间的相互关系。</p><p>8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。</p><p>9）ps s 采用程序信号的格式显示程序状况。</p><p>10）ps S 列出程序时，包括已中断的子程序资料。</p><p>11）ps -t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。</p><p>12）ps u 　以用户为主的格式来显示程序状况。</p><p>13）ps x 　显示所有程序，不以终端机来区分。</p><p>最常用的方法是ps -aux,然后再利用一个管道符号导向到grep去查找特定的进程,然后再对特定的进程进行操作。</p><p>linux上进程有5种状态:</p><p>\1. 运行(正在运行或在运行队列中等待)</p><p>\2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号)</p><p>\3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生)</p><p>\4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放)</p><p>\5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行)</p><p>ps工具标识进程的5种状态码:</p><p>D 不可中断 uninterruptible sleep (usually IO)</p><p>R 运行 runnable (on run queue)</p><p>S 中断 sleeping</p><p>T 停止 traced or stopped</p><p>Z 僵死 a defunct (”zombie”) process</p><p>注: 其它状态还包括W(无驻留页), &lt;(高优先级进程), N(低优先级进程), L(内存锁页).</p><p>使用ps格式输出来查看进程状态:</p><p>ps -eo user,stat..,cmd</p><p>user 用户名</p><p>uid 用户号</p><p>pid 进程号</p><p>ppid 父进程号</p><p>size 内存大小, Kbytes字节.</p><p>vsize 总虚拟内存大小, bytes字节(包含code+data+stack)</p><p>share 总共享页数</p><p>nice 进程优先级(缺省为0, 最大为-20)</p><p>priority(pri) 内核调度优先级</p><p>pmem 进程分享的物理内存数的百分比</p><p>trs 程序执行代码驻留大小</p><p>rss 进程使用的总物理内存数, Kbytes字节</p><p>time 进程执行起到现在总的CPU暂用时间</p><p>stat 进程状态</p><p>cmd(args) 执行命令的简单格式</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    学号linux不是一件一蹴而就的事情，一定要坚持坚持再坚持。自己每每感觉学习linux是一个长期的过程，很耗时间，本文主要记载在学习中一些命令的使用及介绍，以供自己温故而知新。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://shangrila-kun.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="linux基本命令" scheme="https://shangrila-kun.github.io/tags/linux%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>面向对象3</title>
    <link href="https://shangrila-kun.github.io/2018/03/17/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A13/"/>
    <id>https://shangrila-kun.github.io/2018/03/17/面向对象3/</id>
    <published>2018-03-17T04:58:45.000Z</published>
    <updated>2018-03-26T05:42:50.253Z</updated>
    
    <content type="html"><![CDATA[<p>​    本篇主要介绍了抽象类、</p><a id="more"></a><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><blockquote><p>为什么使用抽象类</p><p>​    1：定义Dog类</p><p>​        有颜色属性和叫的方法</p><p>​    2：定义Bird类</p><p>​        有颜色属性和叫的方法</p><p>​    3：定义其父类Animal</p><p>​        1：抽取共性颜色属性和叫的方法</p><p>​            1：颜色的属性可以使用默认初始化值。</p><p>​            2：叫的方法在父类中如何定义？</p><p>​                1：狗是旺旺</p><p>​                2：鸟是叽叽喳喳</p><p>​                3：可以将父类的方法定义为狗叫让鸟继承父类重写叫的方法</p><p>​                    1：鸟怎么确定是否要重写父类方法。</p><p>2：不重写，编译和运行都没有问题，只是执行鸟叫的方法就会出现狗叫</p><p>​                4：父类的方法很难确定。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt; String color;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"旺旺"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"叽叽喳喳"</span>);</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="抽象类的介绍"><a href="#抽象类的介绍" class="headerlink" title="抽象类的介绍"></a>抽象类的介绍</h3><blockquote><p>5：当描述一个类的时候，如果不能确定功能函数如何定义，那么该类就可以定义为抽象类，功能函数应该描述为抽象函数。</p><p>6：抽象类的特点</p><p>​            1：有抽象函数的类，该类一定是抽象类。</p><p>​            2：抽象类中不一定要有抽象函数。</p><p>​            3：抽象类不能使用new创建对象</p><p>​                1：创建对象，使用对象的功能，抽象类的方法，没有方法体。</p><p>​            4：抽象类主要为了提高代码的复用性，让子类继承来使用。</p><p>​            5：编译器强制子类实现抽象类父类的未实现的方法。</p><p>​                1：可以不实现，前提是子类的也要声明为抽象的。</p><p>7：抽象的优点</p><p>​    1：提高代码复用性</p><p>​            2：强制子类实现父类中没有实现的功能</p><p>​            2：提高代码的扩展性，便于后期的代码维护</p><p>8：抽象类不能创建对象，那么抽象类中是否有构造函数？</p><p>​    1：抽象类中一定有构造函数。主要为了初始化抽象类中的属性。通常由子类实现。</p><p>9：final和abstract是否可以同时修饰一个类？  </p><p>​    一定不能同时修饰。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt;</div><div class="line">&gt; String name;</div><div class="line">&gt;</div><div class="line">&gt; <span class="comment">// 抽象类可以有构造函数</span></div><div class="line">&gt; Animal() &#123;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; Animal(String name) &#123;</div><div class="line">&gt; <span class="keyword">this</span>.name = name;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span></span>;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</div><div class="line">&gt; Dog() &#123;</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; Dog(String name) &#123;</div><div class="line">&gt; <span class="keyword">super</span>(name);</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">shout</span><span class="params">()</span> </span>&#123;</div><div class="line">&gt; System.out.println(<span class="string">"旺旺"</span>);</div><div class="line">&gt;</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div><div class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</div><div class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">&gt; <span class="comment">// 抽象类不能创建对象</span></div><div class="line">&gt; <span class="comment">// Animal a=new Animal();</span></div><div class="line">&gt; Dog d = <span class="keyword">new</span> Dog(<span class="string">"旺财"</span>);</div><div class="line">&gt; System.out.println();</div><div class="line">&gt; &#125;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h3 id="注意细节"><a href="#注意细节" class="headerlink" title="注意细节"></a>注意细节</h3><blockquote><p>抽象类可以没有抽象方法（java.awt.*的类就是这样子操作的）。</p><p>抽象类可以继承普通类与抽象类。</p><p>抽象类不能直接使用类名创建实例，但是有构造方法，构造方法是让子类进行初始化。</p><p>抽象类一定有构造方法。</p><p>abstract与其他修饰符的关系:</p><p>​    <strong>final</strong>与abstract不能共存:</p><p>​        final:它的作用  修饰类代表不可以继承  修饰方法不可重写</p><p>​        abstract修饰类就是用来被继承的，修饰方法就是用来被重写的。</p><p>​    <strong>static</strong> static修饰的方法可以用类名调用，</p><p>​         对于abstract修饰的方法没有具体的方法实现，所有不能直接调用，</p><p>​        也就是说不可以与static共存。</p><p>​    <strong>private<em>**</em></strong></p><p>​        private修饰的只能在本类中使用，</p><p>​        abstract方法是用来被子类进行重写的，有矛盾</p><p>​        所有不能共存.</p><p>练习：使用抽象类计算一个矩形与圆形的面积。</p></blockquote><p>##四种类型的值交换</p><h3 id="基本类型的交换"><a href="#基本类型的交换" class="headerlink" title="基本类型的交换"></a>基本类型的交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        <span class="keyword">int</span> a=<span class="number">10</span>;  </div><div class="line">        <span class="keyword">int</span> b=<span class="number">20</span>;  </div><div class="line">        System.out.println(<span class="string">"交换值之前：a="</span>+a+<span class="string">" "</span>+<span class="string">" b="</span>+b);  </div><div class="line">        change(a, b);  </div><div class="line">        System.out.println(<span class="string">"交换值之后：a="</span>+a+<span class="string">" "</span>+<span class="string">" b="</span>+b);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;  </div><div class="line">        <span class="keyword">int</span> temp=a;  </div><div class="line">        a=b;  </div><div class="line">        b=temp;  </div><div class="line">    &#125;  </div><div class="line">&#125;</div><div class="line"><span class="comment">//结果：发现交换值前后没有变量的值发生变化。</span></div></pre></td></tr></table></figure><p><strong>原因分析</strong></p><blockquote><p><img src="http://img.blog.csdn.net/20160716172413634?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></blockquote><h3 id="数组类型的交换"><a href="#数组类型的交换" class="headerlink" title="数组类型的交换"></a>数组类型的交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        <span class="keyword">int</span> [] arr=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;  </div><div class="line">        System.out.println(<span class="string">"交换值之前："</span>+Arrays.toString(arr));  </div><div class="line">        change(arr, <span class="number">1</span>,<span class="number">3</span>);  </div><div class="line">        System.out.println(<span class="string">"交换值之后："</span>+Arrays.toString(arr));  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> []arr,<span class="keyword">int</span> i,<span class="keyword">int</span> j)</span></span>&#123;  </div><div class="line">        <span class="keyword">int</span> temp=arr[i];  </div><div class="line">        arr[i]=arr[j];  </div><div class="line">        arr[j]=temp;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//结果：交换值成功。</span></div></pre></td></tr></table></figure><p><strong>原因分析</strong></p><blockquote><p><img src="http://img.blog.csdn.net/20160716172957082?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></blockquote><h3 id="对象类型的交换"><a href="#对象类型的交换" class="headerlink" title="对象类型的交换"></a>对象类型的交换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Te</span></span>&#123;  </div><div class="line">    <span class="keyword">int</span> x=<span class="number">10</span>;  </div><div class="line">  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Te</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;  </div><div class="line">        <span class="keyword">this</span>.x = x;  </div><div class="line">    &#125;  </div><div class="line">      </div><div class="line">&#125;  </div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;  </div><div class="line">      </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  </div><div class="line">        Te test=<span class="keyword">new</span> Te(<span class="number">1</span>);  </div><div class="line">        System.out.println(<span class="string">"交换值之前："</span>+test.x);  </div><div class="line">        change(test, <span class="number">4</span>);  </div><div class="line">        System.out.println(<span class="string">"交换值之后："</span>+test.x);  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Te test,<span class="keyword">int</span> x)</span></span>&#123;  </div><div class="line">        test.x=x;  </div><div class="line">    &#125;  </div><div class="line">&#125;  </div><div class="line"><span class="comment">//结果：交换成功</span></div></pre></td></tr></table></figure><p><strong>原因分析</strong></p><blockquote><p><img src="http://img.blog.csdn.net/20160716173910338?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p></blockquote><h3 id="字符串类型的值交换"><a href="#字符串类型的值交换" class="headerlink" title="字符串类型的值交换"></a>字符串类型的值交换</h3><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps8FB6.tmp.jpg" alt="img"></p><p>值交换失败。字符串中的值存在常量池中。</p><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wps19F5.tmp.jpg" alt="img"></p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsC747.tmp.jpg" alt="img"></p><blockquote><p>接口(interface)：usb接口，主要是使用来拓展笔记本的功能，那么在java中的接口主要是使用来拓展定义类的功能，可以弥补java中单继承的缺点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pencil</span> </span>&#123;</div><div class="line">String name;</div><div class="line">Pencil() &#123;</div><div class="line">&#125;</div><div class="line">Pencil(String name) &#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"写字"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eraser</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String color = <span class="string">"白色"</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 1：带橡皮的铅笔类继承铅笔类实现橡皮接口</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">PencilWithEraser</span> <span class="keyword">extends</span> <span class="title">Pencil</span> <span class="keyword">implements</span> <span class="title">Eraser</span> </span>&#123;</div><div class="line">PencilWithEraser() &#123;</div><div class="line">&#125;</div><div class="line">PencilWithEraser(String name) &#123;</div><div class="line"><span class="keyword">super</span>(name);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(name + <span class="string">":考试专用"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="keyword">super</span>.name + <span class="string">":带橡皮的铅笔，就是好用"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">PencilWithEraser pe = <span class="keyword">new</span> PencilWithEraser(<span class="string">"中华2B"</span>);</div><div class="line">pe.write();</div><div class="line">pe.clean();</div><div class="line">System.out.println(pe.color);</div><div class="line">System.out.println(PencilWithEraser.color);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>格式</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; <span class="class"><span class="keyword">interface</span> <span class="title">Inter</span></span></div><div class="line">&gt; &#123;</div><div class="line">&gt; <span class="keyword">int</span> num = <span class="number">6</span>;  <span class="comment">//可以定义属性与方法。</span></div><div class="line">&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</div><div class="line">&gt; &#125;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>注意：可以通过javap命令查看.</p><ol><li><p>接口中的所有属性 默认的修饰符是  public static final。</p></li><li><p>接口中的所有方法 默认的修饰符是  public abstract。</p></li></ol><p>疑惑：干嘛不在PencilWithEraser添加remove功能函数，而要通过接口？</p></blockquote><p><img src="file:///C:\Users\ADMINI~1\AppData\Local\Temp\ksohtml\wpsF0C5.tmp.jpg" alt="img"></p><h3 id="接口的特点"><a href="#接口的特点" class="headerlink" title="接口的特点"></a>接口的特点</h3><blockquote><ol><li><p>类实现接口可以通过implements实现，实现接口的时候必须把接口中的所有方法实现,一个类可以实现多个接口。</p></li><li><p>接口中定义的所有的属性默认是public static final的，即静态常量既然是常量，那么定义的时候必须赋值。</p></li><li><p>接口中定义的方法不能有方法体。接口中定义的方法默认添加public abstract</p></li><li><p>有抽象函数的不一定是抽象类，也可以是接口类。</p></li><li><p>由于接口中的方法默认都是抽象的，所以不能被实例化。</p></li><li><p>对于接口而言，可以使用子类来实现接口中未被实现的功能函数。</p></li><li><p>如果实现类中要访问接口中的成员，不能使用super关键字。因为两者之间没有显示的继承关系，况且接口中的成员成员属性是静态的。可以使用接口名直接访问。</p></li><li><p>接口没有构造方法。</p></li></ol></blockquote><h3 id="接口与类、接口之间的关系"><a href="#接口与类、接口之间的关系" class="headerlink" title="接口与类、接口之间的关系"></a>接口与类、接口之间的关系</h3><p>1、接口与类之间是实现关系。</p><blockquote><p>大家之前都知道类与类之间的关系继承，那么接口与类之间又是怎样子的关系呢？<strong>接口与类之间是实现关系</strong>。非抽象类实现接口时，必须把接口里面的所有方法实现。类实现接口用关键字implments，类与接口之间是可以多实现的(即一个类可以实现多个接口)。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Eraser</span> </span>&#123;</div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String color = <span class="string">"白色"</span>;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pencil</span> <span class="keyword">implements</span> <span class="title">Eraser</span> </span>&#123;</div><div class="line">String name;</div><div class="line">Pencil() &#123;</div><div class="line">&#125;</div><div class="line">Pencil(String name) &#123;</div><div class="line"><span class="keyword">this</span>.name = name;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"写字"</span>);</div><div class="line">&#125;</div><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clean</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"涂改..."</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>分析：</p><p>​    原本铅笔没有涂改功能的，但是一旦实现了Eraser接口做了实现，那么就具备了涂改功能，那么接口的作用则是拓展功能。</p><ol><li>接口与接口之间的关系式继承。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span></span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span>,<span class="title">B</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>接口与接口之间的关系是继承，接口可以多继承接口.</p><p><strong>练习：</strong>在现实生活中有部分同学在学校期间只会学习，但是有部分学生除了学习外还会赚钱。</p><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><blockquote><p>1：什么是多态</p><p>​        一个对象的多种状态</p><p>​        （老师）（员工）（儿子）</p><p>​        教师 a =老钟;</p><p>​        员工 b= 老钟;</p><p>​    2：多态体现</p><p>​        1：Father类</p><p>​            1：非静态成员变量x</p><p>​            2：静态成员变量y</p><p>​            3：非静态方法eat,方法体输出父类信息</p><p>​            4：静态方法speak();方法体输出父类信息    </p><p>​        2：Son类</p><p>​            1：非静态成员变量x</p><p>​            2：静态成员变量y</p><p>​            3：非静态方法eat，方法体输出子类信息</p><p>​            4：静态方法speak();方法体输出子类信息</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> x = <span class="number">1</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">2</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"开吃"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"小头爸爸"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line"><span class="keyword">int</span> x = <span class="number">3</span>;</div><div class="line"><span class="keyword">static</span> <span class="keyword">int</span> y = <span class="number">4</span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"大头儿子很能吃"</span>);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>&#123;</div><div class="line">System.out.println(<span class="string">"大头儿子。"</span>);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo10</span> </span>&#123;</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">Father f = <span class="keyword">new</span> Son(); <span class="comment">// 父类引用指向了子类对象。</span></div><div class="line">System.out.println(f.x); <span class="comment">// 1</span></div><div class="line">System.out.println(f.y); <span class="comment">// 2</span></div><div class="line">f.eat(); <span class="comment">// 输出的是子类的。</span></div><div class="line">f.speak(); <span class="comment">// 输出的是父类</span></div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><blockquote><p>3：Son类继承父类</p><p>​            1：创建Father f=new Son(); </p><p>​                1：这就是父类引用指向了子类对象。</p><p>​                2：问f.x=?（非静态）</p><p>​                3：问f.y=?（静态）</p><p>​                4：问f.eat()输出的是子类还是父类信息？（非静态）</p><p>​                5：问f.speak()输出的是子类还是父类信息？（静态）</p><p>​        4：总结</p><p>1：当父类和子类具有相同的非静态成员变量，那么在多态下访问的是父类的成员变量</p><p>2：当父类和子类具有相同的静态成员变量，那么在多态下访问的是父类的静态成员变量</p><p>​            所以：父类和子类有相同的成员变量，多态下访问的是父类的成员变量。</p><p>3：当父类和子类具有相同的非静态方法（就是子类重写父类方法），多态下访问的是子类的成员方法。</p><p>4：当父类和子类具有相同的静态方法（就是子类重写父类静态方法），多态下访问的是父类的静态方法。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本篇主要介绍了抽象类、&lt;/p&gt;
    
    </summary>
    
      <category term="java" scheme="https://shangrila-kun.github.io/categories/java/"/>
    
    
      <category term="面向对象设计" scheme="https://shangrila-kun.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>20171202mysql的那些些坑</title>
    <link href="https://shangrila-kun.github.io/2017/12/02/20171202mysql%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%9B%E5%9D%91/"/>
    <id>https://shangrila-kun.github.io/2017/12/02/20171202mysql的那些些坑/</id>
    <published>2017-12-02T03:37:56.000Z</published>
    <updated>2017-12-02T03:37:56.907Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>nginx的哪些坑</title>
    <link href="https://shangrila-kun.github.io/2017/12/02/20171202nginx%E7%9A%84%E5%93%AA%E4%BA%9B%E5%9D%91/"/>
    <id>https://shangrila-kun.github.io/2017/12/02/20171202nginx的哪些坑/</id>
    <published>2017-12-02T02:34:55.000Z</published>
    <updated>2017-12-03T03:57:25.194Z</updated>
    
    <content type="html"><![CDATA[<p>​    本文主要内容记载我在学习nginx中遇到的各种问题。</p><a id="more"></a><h2 id="wordpress更改默认端口的方法"><a href="#wordpress更改默认端口的方法" class="headerlink" title="wordpress更改默认端口的方法"></a>wordpress更改默认端口的方法</h2><blockquote><p>通过nginx转发到wordpress博客时，我们不想把80端口给wordpress时，我们需要通过nginx监听到80端口，然后准发到指定的wordpress的端口，wordpress默认端口是80端口。</p></blockquote><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><blockquote><p>也可以先使用更改前的端口80访问wordpress，在控制板的设置里面，找到wordpress地址（url），改为端口号，站点地址也该为端口号。</p><p>如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/7882280-286bef55b46d19db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="123.png"></p></blockquote><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><blockquote><p>那就直接修改数据库中表wp_options，</p><ol><li><strong>update</strong> wp_options <strong>set</strong> option_value=’<a href="http://IP:18070" target="_blank" rel="noopener">http://IP:18070</a>‘ <strong>where</strong> option_name=’siteurl’;  </li><li><strong>update</strong> wp_options <strong>set</strong> option_value=’<a href="http://IP:18070" target="_blank" rel="noopener">http://IP:18070</a>‘ <strong>where</strong> option_name=’home’;  </li></ol></blockquote><h3 id="nginx转发代码"><a href="#nginx转发代码" class="headerlink" title="nginx转发代码"></a>nginx转发代码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line">  2     listen 80;</div><div class="line">  3     server_name www.abc.com;</div><div class="line">  4     location /&#123;</div><div class="line">  5             proxy_pass http://127.0.0.1:18070;//此处的端口就是在wordpress后台或者mysql表结构里面改的端口，通过nginx代理到该端口号上去。</div><div class="line">  6     &#125;</div><div class="line">  7 &#125;</div><div class="line">  8 </div><div class="line">  9 server&#123;</div><div class="line"> 10     listen 18070;</div><div class="line"> 11     location ~ ^/.*\.php$ &#123;</div><div class="line"> 12         root /usr/local/web/wlsdata;//静态页面的地址。</div><div class="line"> 13         fastcgi_pass   127.0.0.1:9000;</div><div class="line"> 14         fastcgi_index  index.php;</div><div class="line"> 15         fastcgi_param  SCRIPT_FILENAME  /usr/local/web/wlsdata$fastcgi_script_name;</div><div class="line"> 16         include        fastcgi_params;</div><div class="line"> 17          gzip on;</div><div class="line"> 18     gzip_min_length 1100;</div><div class="line"> 19     gzip_buffers 4 8k;</div><div class="line"> 20     gzip_types text/plain application/x-javascript text/css image;</div><div class="line"> 21     &#125;</div><div class="line"> 22     location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$ &#123;</div><div class="line"> 23             expires 30d;</div><div class="line"> 24             root /usr/local/web/wlsdata;</div><div class="line"> 25         &#125;</div><div class="line"> 26      location / &#123;</div><div class="line"> 27             root   /usr/local/web/wlsdata;//静态页面的地址。</div><div class="line"> 28             index  index.php ;</div><div class="line"> 29      &#125;</div><div class="line"> 30 &#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本文主要内容记载我在学习nginx中遇到的各种问题。&lt;/p&gt;
    
    </summary>
    
      <category term="运维" scheme="https://shangrila-kun.github.io/categories/%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="nginx" scheme="https://shangrila-kun.github.io/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>lnmp安装</title>
    <link href="https://shangrila-kun.github.io/2017/12/02/20171202lnmp%E5%AE%89%E8%A3%85/"/>
    <id>https://shangrila-kun.github.io/2017/12/02/20171202lnmp安装/</id>
    <published>2017-12-02T02:09:14.000Z</published>
    <updated>2017-12-02T03:14:23.514Z</updated>
    
    <content type="html"><![CDATA[<p>​    由于项目需要lnmp，linux、nginx 、mysql、php环境，每次一个个源码安装或者yum安装都稀里糊涂的安装好了，有时候还出现莫名奇怪的问题，于是在网上查找了，使用了军哥的脚本部署lnmp。<a href="https://lnmp.org/install.html" target="_blank" rel="noopener">lnmg一键安装官网及问题解答</a></p><a id="more"></a><h2 id="LNMP一键安装包介绍"><a href="#LNMP一键安装包介绍" class="headerlink" title="LNMP一键安装包介绍"></a>LNMP一键安装包介绍</h2><h3 id="LNMP一键安装包是什么"><a href="#LNMP一键安装包是什么" class="headerlink" title="LNMP一键安装包是什么?"></a><strong>LNMP一键安装包是什么?</strong></h3><blockquote><p>LNMP一键安装包是一个用Linux Shell编写的可以为CentOS/RHEL/Fedora/Aliyun/Amazon、Debian/Ubuntu/Raspbian/DeepinServer/Mint Linux VPS或独立主机安装LNMP(Nginx/MySQL/PHP)、LNMPA(Nginx/MySQL/PHP/Apache)、LAMP(Apache/MySQL/PHP)生产环境的Shell程序。</p></blockquote><h3 id="我们为什么需要它"><a href="#我们为什么需要它" class="headerlink" title="我们为什么需要它?"></a><strong>我们为什么需要它?</strong></h3><blockquote><p>编译安装需要输入大量的命令，如果是配置生产环境需要耗费大量的时间。<br>不会Linux的站长或Linux新手想使用Linux作为生产环境……</p></blockquote><h3 id="它有什么优势和功能"><a href="#它有什么优势和功能" class="headerlink" title="它有什么优势和功能?"></a><strong>它有什么优势和功能?</strong></h3><blockquote><p>无需一个一个的输入命令，无需值守，编译安装优化编译参数，提高性能，解决不必要的软件间依赖，特别针对配置自动优化。</p><p>支持自定义Nginx、PHP编译参数及网站和数据库目录、支持生成LetseEcrypt证书、LNMP模式支持多PHP版本、支持单独安装Nginx/MySQL/MariaDB/Pureftpd服务器，同时提供一些实用的辅助工具如：虚拟主机管理、FTP用户管理、Nginx、MySQL/MariaDB、PHP的升级、常用缓存组件Redis/Xcache等的安装、重置MySQL root密码、502自动重启、日志切割、SSH防护DenyHosts/Fail2Ban、备份等许多实用脚本。</p></blockquote><h3 id="如何获取它"><a href="#如何获取它" class="headerlink" title="如何获取它?"></a><strong>如何获取它?</strong></h3><blockquote><p>你可以自由 <a href="https://lnmp.org/download.html" target="_blank" rel="noopener">下载</a> 并使用它在VPS或独立服务器上，做为真正的生产环境或测试环境。</p></blockquote><h3 id="我们为什么采用LNMP这种架构"><a href="#我们为什么采用LNMP这种架构" class="headerlink" title="我们为什么采用LNMP这种架构?"></a><strong>我们为什么采用LNMP这种架构?</strong></h3><blockquote><p>采用Linux、PHP、MySQL的优点我们不必多说。</p><p>Nginx是一个小巧而高效的Linux下的Web服务器软件，是由 Igor Sysoev 为俄罗斯访问量第二的 Rambler.ru 站点开发的，已经在一些俄罗斯的大型网站上运行多年，目前很多国内外的门户网站、行业网站也都在是使用Nginx，相当的稳定。</p><p>Nginx相当的稳定、功能丰富、安装配置简单、低系统资源<a href="https://lnmp.org/nginx.html" target="_blank" rel="noopener">…</a></p></blockquote><h2 id="安装教程"><a href="#安装教程" class="headerlink" title="安装教程"></a>安装教程</h2><h3 id="系统需求"><a href="#系统需求" class="headerlink" title="系统需求"></a>系统需求</h3><blockquote><ul><li>CentOS/RHEL/Fedora/Debian/Ubuntu/Raspbian/Deepin Server/Aliyun/Amazon/Mint Linux发行版</li><li>需要5GB以上硬盘剩余空间，MySQL 5.7,MariaDB 10至少9GB剩余空间</li><li>需要128MB以上内存(如果为128MB的小内存VPS,Xen的需要有SWAP,OpenVZ的至少要有128MB以上的vSWAP或突发内存)，注意小内存请勿使用64位系统！</li><li><strong>安装MySQL 5.6或5.7及MariaDB 10必须1G以上内存!</strong>。</li><li>VPS或服务器必须已经联网，且必须设置的是网络源不能是光盘源，同时VPS/服务器 DNS要正常！</li><li>Linux下区分大小写，输入命令时请注意！</li><li>CentOS 5,Debian 6及之前版本其官网已经结束支持无法使用！</li></ul><p>LNMP一键安装包 V1.4 已经在<a href="https://www.vpser.net/go/vultr" target="_blank" rel="noopener">Vultr</a>、<a href="https://www.vpser.net/go/aoyohost" target="_blank" rel="noopener">遨游主机</a>、<a href="https://www.vpser.net/go/bandwagonhost" target="_blank" rel="noopener">搬瓦工</a>、<a href="https://www.vpser.net/go/photonvps" target="_blank" rel="noopener">PhotonVPS</a>、<a href="https://www.vpser.net/go/oneasiahost" target="_blank" rel="noopener">OneAsiahost新加坡VPS</a>、<a href="https://www.vpser.net/go/budgetvm" target="_blank" rel="noopener">BudgetVM</a>、<a href="https://www.vpser.net/go/digitalocean" target="_blank" rel="noopener">DigitalOcean</a>、<a href="https://www.vpser.net/go/locvps" target="_blank" rel="noopener">LocVPS</a>、<a href="https://www.vpser.net/go/linode" target="_blank" rel="noopener">Linode</a>、<a href="https://www.vpser.net/go/diahosting" target="_blank" rel="noopener">DiaHosting</a>、<a href="https://www.vpser.net/go/kvmla" target="_blank" rel="noopener">KVMLA</a>、<a href="https://www.vpser.net/go/jwdns" target="_blank" rel="noopener">景文互联</a>、<a href="https://www.vpser.net/go/ramnode" target="_blank" rel="noopener">RamNode</a>、<a href="https://www.vpser.net/go/buyvm" target="_blank" rel="noopener">BuyVM</a>、<a href="https://www.vpser.net/go/80vps" target="_blank" rel="noopener">80VPS</a>、<a href="https://www.vpser.net/go/kiiyi" target="_blank" rel="noopener">快易互联</a>、<a href="https://www.vpser.net/go/aliyun" target="_blank" rel="noopener">阿里云</a>等众多VPS的CentOS 6-7、RHEL 6-7、Fedora 21-23、Debian 7-9、Ubuntu 10.04-17.04的32位和64位系统上测试通过(CentOS 5,Debian 6及之前版本其官网已经结束支持无法使用,Debian9上Apache需选2.4.26版本以上，<strong>深度/deepin只能使用服务器版,桌面版勿用！！</strong>)。</p></blockquote><h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><blockquote><p><strong>1、使用putty或类似的SSH工具登陆VPS或服务器；</strong></p><p>登陆后运行：<strong>screen -S lnmp</strong></p><p>如果提示screen: command not found 命令不存在可以执行：yum install screen 或 apt-get install screen安装，详细内容参考<a href="https://www.vpser.net/manage/run-screen-lnmp.html" target="_blank" rel="noopener">screen教程</a>。</p><p><strong>2、下载并安装LNMP一键安装包：</strong></p><p>您可以选择使用下载版(推荐美国及海外VPS或空间较小用户使用)或者完整版(推荐国内VPS使用，国内用户可用在<a href="https://lnmp.org/download.html" target="_blank" rel="noopener">下载</a>中找国内下载地址替换)，两者没什么区别，只是完整版把一些需要的源码文件预先放到安装包里。<strong>深度/deepin只能使用服务器版，桌面版请勿安装！！</strong></p><p>安装LNMP稳定版<br><strong>wget -c <a href="http://soft.vpser.net/lnmp/lnmp1.4.tar.gz" target="_blank" rel="noopener">http://soft.vpser.net/lnmp/lnmp1.4.tar.gz</a> &amp;&amp; tar zxf lnmp1.4.tar.gz &amp;&amp; cd lnmp1.4 &amp;&amp; ./install.sh lnmp</strong></p><p>默认安装lnmp可不写，如需要安装LNMPA或LAMP，将./install.sh 后面的参数替换为lnmpa或lamp即可。如需更改网站和数据库目录先修改安装包目录下的 lnmp.conf 文件。</p><p>如下载速度慢请更换其他下载节点，详情请看<a href="https://lnmp.org/download.html" target="_blank" rel="noopener">下载页面</a>。<a href="https://lnmp.org/faq/lnmp-download-source.html" target="_blank" rel="noopener">LNMP下载节点具体替换方法</a>。</p><p>运行上述LNMP安装命令后，会出现如下提示：<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-1.png" alt="img"><br>目前提供了较多的MySQL、MariaDB版本和不安装数据库的选项，需要<strong>注意的是MySQL 5.6,5.7及MariaDB 10必须在1G以上内存的更高配置上才能选择</strong>！</p><p>输入对应MySQL或MariaDB版本前面的序号，回车进入下一步.</p><p><img src="https://lnmp.org/images/1.4/lnmp1.4-install-2.png" alt="img"><br>需要设置MySQL的root密码（不输入直接回车将会设置为root）如果输入有错误需要删除时，可以按住Ctrl再按Backspace键进行删除(个别情况下是只需要Backspace键)。输入后回车进入下一步，如下图所示：<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-3.png" alt="img"><br>询问是否需要启用MySQL InnoDB，InnoDB引擎默认为开启，一般建议开启，直接回车或输入 y ，如果确定确实不需要该引擎可以输入 n，输入完成，回车进入下一步。</p><p>注意：选择PHP7等高版本时需要自行确认是否与自己的程序兼容。<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-4.png" alt="img"><br>输入要选择的PHP版本的序号，回车进入下一步，选择是否安装内存优化：<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-5.png" alt="img"><br>可以选择不安装、Jemalloc或TCmalloc，输入对应序号回车，直接回车为默认为不安装。</p><p>如果是LNMPA或LAMP的话还会提示<img src="https://lnmp.org/images/1.4/lnmp1.4-install-6.png" alt="img">“Please enter Administrator Email Address:”，需要设置管理员邮箱，该邮箱会在报错时显示在错误页面上。</p><p>再选择Apache版本<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-7.png" alt="img"><br>按提示输入对应版本前面的数字序号，回车。</p><p>提示”Press any key to install…or Press Ctrl+c to cancel”后，按回车键确认开始安装。<br>LNMP脚本就会自动安装编译Nginx、MySQL、PHP、phpMyAdmin、Zend Optimizer这几个软件。</p><p>安装时间可能会几十分钟到几个小时不等，主要是机器的配置网速等原因会造成影响。</p></blockquote><h2 id="安装完成效果"><a href="#安装完成效果" class="headerlink" title="安装完成效果"></a>安装完成效果</h2><blockquote><p>如果显示Nginx: OK，MySQL: OK，PHP: OK<br><img src="https://lnmp.org/images/1.4/lnmp1.4-install-success.png" alt="img"><br>并且Nginx、MySQL、PHP都是running，80和3306端口都存在，并提示安装使用的时间及Install lnmp V1.4 completed! enjoy it.的话，说明已经安装成功。</p><p>安装完成接下来开始使用就可以了，按<a href="https://lnmp.org/faq/lnmp-vhost-add-howto.html" target="_blank" rel="noopener"><strong>添加虚拟主机教程</strong></a>，添加虚拟主机后可以使用<a href="https://lnmp.org/faq/sftp.html" target="_blank" rel="noopener">sftp</a>或<a href="https://lnmp.org/faq/ftpserver.html" target="_blank" rel="noopener">ftp服务器</a>上传网站代码，将域名解析到VPS或服务器的IP上，解析生效即可使用。</p></blockquote><h2 id="安装失败效果"><a href="#安装失败效果" class="headerlink" title="安装失败效果"></a>安装失败效果</h2><blockquote><p><img src="https://lnmp.org/images/1.4/lnmp1.4-install-failed.png" alt="img"><br>如果出现类似上图的提示，有一个没安装成功表明安装失败！！需要用<a href="http://www.vpser.net/manage/winscp.html" target="_blank" rel="noopener">winscp</a>或其他类似工具，将/root目录下面的lnmp-install.log下载下来，到<a href="http://bbs.vpser.net/forum-25-1.html" target="_blank" rel="noopener">LNMP支持论坛</a>发帖注明你的系统发行版名称及版本号、32位还是64位等信息，并将lnmp-install.log压缩以附件形式上传到论坛，我们会通过日志查找错误，并给予相应的解决方法。</p><p>默认LNMP是不安装FTP服务器的，如需要FTP服务器：<a href="https://lnmp.org/faq/ftpserver.html" target="_blank" rel="noopener">https://lnmp.org/faq/ftpserver.html</a></p><p>5、添加、删除虚拟主机及伪静态管理</p><p><a href="https://lnmp.org/faq/lnmp-vhost-add-howto.html" target="_blank" rel="noopener">https://lnmp.org/faq/lnmp-vhost-add-howto.html</a></p><p>6、eAccelerator、xcache、memcached、imageMagick、ionCube、redis、opcache的安装</p><p><a href="https://lnmp.org/faq/addons.html" target="_blank" rel="noopener">https://lnmp.org/faq/addons.html</a></p><p>7、LNMP相关软件目录及文件位置</p><p><a href="https://lnmp.org/faq/lnmp-software-list.html" target="_blank" rel="noopener">https://lnmp.org/faq/lnmp-software-list.html</a></p><p>8、LNMP状态管理命令</p><p><a href="https://lnmp.org/faq/lnmp-status-manager.html" target="_blank" rel="noopener">https://lnmp.org/faq/lnmp-status-manager.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    由于项目需要lnmp，linux、nginx 、mysql、php环境，每次一个个源码安装或者yum安装都稀里糊涂的安装好了，有时候还出现莫名奇怪的问题，于是在网上查找了，使用了军哥的脚本部署lnmp。&lt;a href=&quot;https://lnmp.org/install.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;lnmg一键安装官网及问题解答&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="软件安装" scheme="https://shangrila-kun.github.io/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="linux" scheme="https://shangrila-kun.github.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>用阿里云免费ssl证书把网站从http变成https</title>
    <link href="https://shangrila-kun.github.io/2017/11/18/%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%85%8D%E8%B4%B9ssl%E8%AF%81%E4%B9%A6%E6%8A%8A%E7%BD%91%E7%AB%99%E4%BB%8Ehttp%E5%8F%98%E6%88%90https/"/>
    <id>https://shangrila-kun.github.io/2017/11/18/用阿里云免费ssl证书把网站从http变成https/</id>
    <published>2017-11-18T12:32:00.000Z</published>
    <updated>2017-11-19T09:45:52.402Z</updated>
    
    <content type="html"><![CDATA[<p>​    实验室小程序需要调用到全程版接口，但是全程版接口都是http形式，需要http转https，整理了这篇文章，解决这个问题。</p><p>​<a id="more"></a></p><h3 id="1、登录阿里云后台找到产品与服务、找到证书"><a href="#1、登录阿里云后台找到产品与服务、找到证书" class="headerlink" title="1、登录阿里云后台找到产品与服务、找到证书"></a>1、登录阿里云后台找到产品与服务、找到证书</h3><p><a href="http://jingyan.baidu.com/album/9f7e7ec09c80976f281554f1.html?picindex=1" target="_blank" rel="noopener"><img src="https://imgsa.baidu.com/exp/w=500/sign=ccb7fe399813b07ebdbd50083cd79113/77c6a7efce1b9d16cabfe379f8deb48f8c5464a9.jpg" alt="用阿里云免费ssl证书把网站从http变成https">步骤阅读</a></p><h3 id="2、免费购买完成后，在订单里不去信息，输入需要使用Https服务的详细子域名，填写个人信息"><a href="#2、免费购买完成后，在订单里不去信息，输入需要使用Https服务的详细子域名，填写个人信息" class="headerlink" title="2、免费购买完成后，在订单里不去信息，输入需要使用Https服务的详细子域名，填写个人信息"></a>2、免费购买完成后，在订单里不去信息，输入需要使用Https服务的详细子域名，填写个人信息</h3><p><img src="http://images2015.cnblogs.com/blog/601899/201703/601899-20170331115509555-875540633.png" alt="img"></p><h3 id="3、完成信息后，接下来就是等待审批结果了，审批通过后，下载，"><a href="#3、完成信息后，接下来就是等待审批结果了，审批通过后，下载，" class="headerlink" title="3、完成信息后，接下来就是等待审批结果了，审批通过后，下载，"></a>3、完成信息后，接下来就是等待审批结果了，审批通过后，下载，</h3><p><img src="http://images2015.cnblogs.com/blog/601899/201703/601899-20170331115606945-2078304494.png" alt="img"></p><p>据自己服务器的实际情况 ，选择相应类型，完成安装，我的是nginx。</p><h3 id="4、将下载的两个文件安装到nginx"><a href="#4、将下载的两个文件安装到nginx" class="headerlink" title="4、将下载的两个文件安装到nginx"></a>4、将下载的两个文件安装到nginx</h3><p>​    建议安装最新的nginx，nginx依赖</p><p>​    nginx依赖以下模块：l  gzip模块需要 zlib 库l  rewrite模块需要 pcre 库l  ssl 功能需要openssl库</p><h4 id="4-1-安装pcre"><a href="#4-1-安装pcre" class="headerlink" title="4.1.安装pcre"></a>4.1.安装pcre</h4><ol><li>获取pcre编译安装包，在<a href="http://www.pcre.org/" target="_blank" rel="noopener">http://www.pcre.org/</a>上可以获取当前最新的版本</li><li>解压缩pcre-xx.tar.gz包。</li><li>进入解压缩目录，执行./configure。</li><li>make &amp; make install</li></ol><h4 id="4-2-安装openssl"><a href="#4-2-安装openssl" class="headerlink" title="4.2.安装openssl"></a>4.2.安装openssl</h4><ol><li>获取openssl编译安装包，在<a href="http://www.openssl.org/source/" target="_blank" rel="noopener">http://www.openssl.org/source/</a>上可以获取当前最新的版本。</li><li>解压缩openssl-xx.tar.gz包。</li><li>进入解压缩目录，执行./config。</li><li>make &amp; make install</li></ol><h4 id="4-3-安装zlib"><a href="#4-3-安装zlib" class="headerlink" title="4.3.安装zlib"></a>4.3.安装zlib</h4><ol><li>获取zlib编译安装包，在<a href="http://www.zlib.net/" target="_blank" rel="noopener">http://www.zlib.net/</a>上可以获取当前最新的版本。</li></ol><ol><li><p>解压缩openssl-xx.tar.gz包。</p></li><li><p>进入解压缩目录，执行./configure。</p></li><li><p>make &amp; make install </p><h4 id="4-4安装nginx"><a href="#4-4安装nginx" class="headerlink" title="4.4安装nginx"></a>4.4安装nginx</h4><p>  1.获取nginx，在<a href="http://nginx.org/en/download.html上可以获取当前最新的版本。" target="_blank" rel="noopener">http://nginx.org/en/download.html上可以获取当前最新的版本。</a></p><p>  2.解压缩nginx-xx.tar.gz包。</p><ol><li>进入解压缩目录，执行./configure</li><li>make &amp; make install</li></ol><p>若安装时找不到上述依赖模块，使用–with-openssl=<openssl_dir>、–with-pcre=<pcre_dir>、–with-zlib=<zlib_dir>指定依赖的模块目录。如已安装过，此处的路径为安装目录；若未安装，则此路径为编译安装包路径，nginx将执行模块的默认编译安装。</zlib_dir></pcre_dir></openssl_dir></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    实验室小程序需要调用到全程版接口，但是全程版接口都是http形式，需要http转https，整理了这篇文章，解决这个问题。&lt;/p&gt;
&lt;p&gt;​
    
    </summary>
    
      <category term="database" scheme="https://shangrila-kun.github.io/categories/database/"/>
    
    
      <category term="sql" scheme="https://shangrila-kun.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点总结（未完待续）</title>
    <link href="https://shangrila-kun.github.io/2017/11/18/20171118database/"/>
    <id>https://shangrila-kun.github.io/2017/11/18/20171118database/</id>
    <published>2017-11-18T12:32:00.000Z</published>
    <updated>2018-01-06T12:18:02.363Z</updated>
    
    <content type="html"><![CDATA[<p>​    本文内容记载在我在学习数据库这门课程中的知识点，内容涵盖对sql关键字的讲解，sql语句的具体案例及分析。</p><a id="more"></a><h2 id="SQL中的关键字讲解"><a href="#SQL中的关键字讲解" class="headerlink" title="SQL中的关键字讲解"></a>SQL中的关键字讲解</h2><h3 id="distinct用法"><a href="#distinct用法" class="headerlink" title="distinct用法"></a>distinct用法</h3><blockquote><p>作用于单列</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; select distinct name from A</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>作用于多列</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; select distinct name, id from A //实际上是根据name和id两个字段来去重的，这种方式Access和SQL Server同时支持。</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>COUNT统计</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; select count(distinct name) from A;  --表中name去重后的数目， SQL Server支持，而Access不支持</div><div class="line">&gt; count是不能统计多个字段的，下面的SQL在SQL Server和Access中都无法运行。</div><div class="line">&gt; select count(distinct name, id) from A;</div><div class="line">&gt; 若想使用，请使用嵌套查询，如下：</div><div class="line">&gt; select count(*) from (select distinct xing, name from B) AS M;</div><div class="line">&gt;</div></pre></td></tr></table></figure><p>distinct必须放在开头</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; select id, distinct name from A;   --会提示错误，因为distinct必须放在开头</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="Union-amp-amp-Union-ALL的用法"><a href="#Union-amp-amp-Union-ALL的用法" class="headerlink" title="Union&amp;&amp;Union ALL的用法"></a>Union&amp;&amp;Union ALL的用法</h3><blockquote><p>UNION 操作符用于合并两个或多个 SELECT 语句的结果集。</p><p>请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。</p><p><strong>Union因为要进行重复值扫描，所以效率低。如果合并没有刻意要删除重复行，那么就使用Union All</strong></p><p><strong>两个要联合的SQL语句 字段个数必须一样，而且字段类型要“相容”（一致）</strong>  </p><p>如果我们需要将两个select语句的结果作为一个整体显示出来，我们就需要用到union或者union all关键字。union(或称为联合)的作用是将多个结果合并在一起显示出来。 </p><p>union和union all的区别是,union会自动压缩多个结果集合中的重复结果，而union all则将所有的结果全部显示出来，不管是不是重复。 </p><p>Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序； </p><p>Union All：对两个结果集进行并集操作，包括重复行，不进行排序； </p><p>Intersect：对两个结果集进行交集操作，不包括重复行，同时进行默认规则的排序； </p><p>Minus：对两个结果集进行差操作，不包括重复行，同时进行默认规则的排序。 </p><p>可以在最后一个结果集中指定Order by子句改变排序方式。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; select * from emp where deptno &gt;= 20 </div><div class="line">&gt; union all </div><div class="line">&gt; select * from emp where deptno &lt;= 30 </div><div class="line">&gt; select empno,ename from emp </div><div class="line">&gt; union </div><div class="line">&gt; select deptno,dname from dept </div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h2 id="案例表结构"><a href="#案例表结构" class="headerlink" title="案例表结构"></a>案例表结构</h2><h3 id="c、o、p、a表结构"><a href="#c、o、p、a表结构" class="headerlink" title="c、o、p、a表结构"></a>c、o、p、a表结构</h3><blockquote><p>表结构如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; CREATE TABLE  customers (//顾客表</div><div class="line">&gt; cid CHAR(4) NOT NULL,</div><div class="line">&gt; cname VARCHAR(13),</div><div class="line">&gt; city VARCHAR(20),</div><div class="line">&gt; discnt REAL,</div><div class="line">&gt; PRIMARY KEY(cid) );</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; CREATE TABLE agents (//代理商表</div><div class="line">&gt; aid CHAR(3) NOT NULL,</div><div class="line">&gt; aname VARCHAR(13),</div><div class="line">&gt; city VARCHAR(20),</div><div class="line">&gt; percent SMALLINT,</div><div class="line">&gt; PRIMARY KEY (aid) );</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; CREATE TABLE  products (//产品表</div><div class="line">&gt; pid CHAR(3) NOT NULL,</div><div class="line">&gt; pname VARCHAR(13),</div><div class="line">&gt; city VARCHAR(20),</div><div class="line">&gt; quantity INTEGER,</div><div class="line">&gt; price DOUBLE PRECISION,</div><div class="line">&gt; PRIMARY KEY(pid) );</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt; CREATE TABLE  orders (//订单表</div><div class="line">&gt; ordno INTEGER NOT NULL,</div><div class="line">&gt; month CHAR(3),</div><div class="line">&gt; cid CHAR(4),</div><div class="line">&gt; aid CHAR(3),</div><div class="line">&gt; pid CHAR(3),</div><div class="line">&gt; qty INTEGER,</div><div class="line">&gt; dollars DOUBLE PRECISION,</div><div class="line">&gt; PRIMARY KEY(ordno) );</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h2 id="关系代数"><a href="#关系代数" class="headerlink" title="关系代数"></a>关系代数</h2><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt; query in relational algebra (Theta-Join)</div><div class="line">&gt; ( R where Condition ) [ A1, A2, ..., Am ]</div><div class="line">&gt; SELECT  A1, A2, ..., Am</div><div class="line">&gt; FROM      R</div><div class="line">&gt; WHERE   Condition ;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; query in relational algebra (PRODUCT)</div><div class="line">&gt; ((R1R2...Rn) where Condition) [A1,A2,...,Am]</div><div class="line">&gt; query in SQL</div><div class="line">&gt; SELECT  A1, A2, ..., Am</div><div class="line">&gt; FROM      R1, R2, …, Rn</div><div class="line">&gt; WHERE   Condition ;</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; query in relational algebra (Theta-Join)</div><div class="line">&gt; ( R Condition S ) [ A1, A2, ..., Am ]</div><div class="line">&gt; query in SQL</div><div class="line">&gt; SELECT  A1, A2, ..., Am</div><div class="line">&gt; FROM      R, S</div><div class="line">&gt; WHERE   Condition ;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&gt; Exp 4.3.1 Find aid and names of agents that are based in New York.</div><div class="line">&gt; Relational Algebra</div><div class="line">&gt; (AGENTS where city=‘New York’) [ aid, aname ]</div><div class="line">&gt; SQL</div><div class="line">&gt; SELECT  aid, aname</div><div class="line">&gt; FROM      agents</div><div class="line">&gt; WHERE   city = 'New York’ ;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; Exp 4.3.2 Display all values of customers in table CUSTOMERS.</div><div class="line">&gt; Relational Algebra</div><div class="line">&gt; CUSTOMERS  [ cid, cname, city, discnt ]</div><div class="line">&gt;</div></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; Exp 4.3.4 Retrieve all (cname, aname) pairs where the customer places an order through the agent.</div><div class="line">&gt; Relational Algebra</div><div class="line">&gt; ( C[cid, cname] oo O ) oo A ) [ cname, aname ]//join 连接</div><div class="line">&gt; ((C x O x A) where C.cid=O.cid and O.aid=A.aid) [ C.cname, A.aname ]//乘积</div><div class="line">&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; Exp 4.5.5: Find cids for customers who order all products ordered by customer c006.</div><div class="line">&gt;       ORDERS [ cid, pid ]  除以 ( ORDERS where cid = ‘c006’ ) [ pid ]</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><h3 id="子查询的定义"><a href="#子查询的定义" class="headerlink" title="子查询的定义"></a>子查询的定义</h3><blockquote><p>定义：子查询本质上是嵌套进其他SELECT,UPDATE,INSERT,DELETE语句的一个被限制的SELECT语句,在子查询中，只有下面几个子句可以使用</p><ol><li>SELECT子句（必须）</li><li>FROM子句(必选）</li><li>WHERE子句(可选)</li><li>GROUP BY(可选)</li><li>HAVING(可选)</li><li>ORDER BY(只有在TOP关键字被使用时才可用)</li></ol><p>子查询也可以嵌套在其他子查询中,这个嵌套最多可达32层。子查询也叫内部查询(Inner query)或者内部选择(Inner Select),而包含子查询的查询语句也叫做外部查询</p></blockquote><h3 id="子查询的谓词"><a href="#子查询的谓词" class="headerlink" title="子查询的谓词"></a>子查询的谓词</h3><blockquote><p>in 谓词（predicate）expr [NOT] IN ( subquery )</p><p>The Quantified Comparison Predicate (量化比较谓词)       expr q SOME|ANY|ALL( subquery )</p><p>The EXISTS Predicate  [NOT] EXISTS ( subquery )</p><p>The BETWEEN Predicate  expr [NOT] BETWEEN expr1 AND expr2</p><p>The IS NULL Predicate column  IS [NOT] NULL</p><p>The LIKE Predicate column [NOT] LIKE val1 [ ESCAPE val2 ]</p><blockquote><p>§underscore ( _ ): any single character</p><p>§percent ( % ): any sequence of zero or morecharacters</p></blockquote></blockquote><h3 id="子查询的执行分析"><a href="#子查询的执行分析" class="headerlink" title="子查询的执行分析"></a>子查询的执行分析</h3><p>​    原文链接：<a href="https://www.cnblogs.com/CareySon/archive/2011/07/18/2109406.html" target="_blank" rel="noopener">点击</a> </p><blockquote><p><strong>子查询的简单描述</strong> ：</p><p> 通常来讲，子查询按照子查询所返回数据的类型，可以分为三种，分别为：</p><ol><li>返回一张数据表(Table)</li><li>返回一列值(Column)</li><li>返回单个值(Scalar)</li></ol></blockquote><h4 id="子查询做数据源的使用"><a href="#子查询做数据源的使用" class="headerlink" title="子查询做数据源的使用"></a>子查询做数据源的使用</h4><blockquote><p>  当子查询在外部查询的<strong>FROM</strong>子句之后使用时,子查询被当作一个<strong>数据源</strong>使用,即使这时子查询只返回一个单一值(Scalar)或是一列值(Column)，在这里依然可以看作一个特殊的<strong>数据源</strong>,即一个二维数据表(Table).作为数据源使用的子查询很像一个<strong>View(视图),</strong>只是这个子查询只是临时存在，并不包含在数据库中。</p>  <figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&gt;   SELECT     P.ProductID, P.Name, P.ProductNumber, M.Name AS ProductModelName</div><div class="line">&gt;   FROM         Production.Product AS P INNER JOIN</div><div class="line">&gt;   (SELECT     Name, ProductModelID</div><div class="line">&gt;   FROM          Production.ProductModel) AS M </div><div class="line">&gt;   ON P.ProductModelID = M.ProductModelID</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote></blockquote><h4 id="子查询作为选择条件的使用"><a href="#子查询作为选择条件的使用" class="headerlink" title="子查询作为选择条件的使用"></a>子查询作为选择条件的使用</h4><blockquote><p>​     作为选择条件的子查询也是子查询相对最复杂的应用.</p><p>​    作为选择条件的子查询是那些只返回<strong>一列(Column)</strong>的子查询，如果作为选择条件使用，即使只返回<strong>单个值</strong>，也可以看作是只有<strong>一行</strong>的<strong>一列.</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; select   distinct  cid</div><div class="line">&gt; from     orders</div><div class="line">&gt; where   aid  IN  (</div><div class="line">&gt; select  aid         --uncorrelated Subquery:(a05,a06)非相关的子查询，更快</div><div class="line">&gt; from  agents</div><div class="line">&gt; where  city= ‘Duluth’  or  city=‘Dallas’)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>  但是要强调的是，不要用IN和NOT IN关键字，这会引起很多潜在的问题，这篇文章对这个问题有着很好的阐述:<a href="http://wiki.lessthandot.com/index.php/Subquery_typo_with_using_in" target="_blank" rel="noopener">http://wiki.lessthandot.com/index.php/Subquery_typo_with_using_in</a>。这篇文章的观点是永远不要再用IN和NOT IN关键字，我的观点是存在即合理，我认为只有在IN里面是固定值的时候才可以用IN和NOT IN，比如： IN (25,33)</p><p>只有在上面这种情况下，使用IN和NOT IN关键字才是安全的，其他情况下，最好使用EXISTS,NOT EXISTS,JOIN关键字来进行替代. 除了IN之外，用于选择条件的关键字还有<strong>ANY</strong>和<strong>ALL</strong>,这两个关键字和其字面意思一样. 和”&lt;”,”&gt;”,”=”连接使用</p><p> 在作为ANY和ALL关键字在子查询中使用时，所实现的效果如下</p><table><thead><tr><th>=ANY</th><th>和IN等价</th></tr></thead><tbody><tr><td>&lt;&gt;ALL</td><td>和NOT IN等价</td></tr><tr><td>&gt;ANY</td><td>大于最小的(&gt;MIN)</td></tr><tr><td>&lt;ANY</td><td>小于最大的(&lt;MAX)</td></tr><tr><td>&gt;ALL</td><td>大于最大的(&gt;MAX)</td></tr><tr><td>&lt;ALL</td><td>小于最小的(&lt;MIN)</td></tr><tr><td>=ALL</td><td>下面说</td></tr></tbody></table><p>   =ALL关键字很少使用，这个的效果在子查询中为如果只有一个返回值，则和“=”相等，而如果有多个返回值，结果为空。</p><p>这里要注意，SQL是一种很灵活的语言，就像子查询所实现的效果可以使用JOIN来实现一样（效果一样，实现思路不同），ANY和ALL所实现的效果也完全可以使用其他方式来替代,按照上面表格所示，&gt;ANY和&gt;MIN完全等价，比如下面两个查询语句完全等价</p><p>IN             is    =SOME</p><p>NOT IN    is    &lt;&gt;ALL</p></blockquote><h4 id="相关子查询和EXISTS关键字"><a href="#相关子查询和EXISTS关键字" class="headerlink" title="相关子查询和EXISTS关键字"></a>相关子查询和EXISTS关键字</h4><blockquote><p>前面所说的查询都是<strong>无关子查询(Uncorrelated subquery),</strong>子查询中还有一类很重要的查询是<strong>相关子查询(Correlated subquery),也叫重复子查询</strong>比如，还是上面那个查询，用相关子查询来写:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt; SELECT  distinct  cname FROM   customers  c</div><div class="line">&gt; WHERE ‘p05’  IN  ( select pid    --correlated Subquery 相关的子查询</div><div class="line">&gt; from  orders  o</div><div class="line">&gt; where o.cid=c.cid );</div><div class="line">&gt; SELECT [FirstName],[MiddleName],[LastName] FROM [AdventureWorks].[Person].[Contact] c</div><div class="line">&gt; WHERE EXISTS(SELECT *</div><div class="line">&gt;   FROM [AdventureWorks].[HumanResources].[Employee] e</div><div class="line">&gt;   WHERE c.ContactID=e.ContactID AND e.SickLeaveHours&gt;68)</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>如何区别<strong>相关子查询</strong>和<strong>无关子查询</strong>呢?最简单的办法就是直接看子查询本身能否执行。</p><p>上面的<strong>无关子查询</strong>，整个查询过程可以看作是<strong>子查询</strong>首先返回SQLResult(SQL结果集),然后交给<strong>外部查询</strong>使用，整个过程<strong>子查询</strong>只执行一次</p><p>  而相反,作为<strong>相关子查询</strong>,子查询的执行的次数依赖于外部查询，外部查询每执行一行，子查询执行一次。</p><p> 如上面代码所示。上面的相关子查询实际上会执行N次（N取决与外部查询的行数），外部查询每执行一行，都会将对应行所用的参数传到子查询中，如果子查询有对应值，则返回TRUE（既当前行被选中并在结果中显示），如果没有，则返回FALSE。然后重复执行下一行。</p></blockquote><h4 id="子查询作为计算列使用"><a href="#子查询作为计算列使用" class="headerlink" title="子查询作为计算列使用"></a>子查询作为计算列使用</h4><blockquote><p>当<strong>子查询</strong>作为<strong>计算列</strong>使用时，只返回单个值(Scalar) 。用在SELECT语句之后，作为计算列使用。同样分为<strong>相关子查询</strong>和<strong>无关子查询</strong></p><p>​    <strong>相关子查询</strong>的例子比如：我想取得每件产品的名称和总共的销量。</p><p>表t_product    id  ,productName;</p><p>表t_order  id ,orderNo,productId</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&gt; select productName , (select count(*) from t_order o where p.id=o.productId ) as totalNum </div><div class="line">&gt;</div><div class="line">&gt; from t_product p ;//相关的子查询</div><div class="line">&gt;   </div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>当<strong>子查询</strong>作为<strong>计算列</strong>使用时，会针对<strong>外部查询</strong>的每一行，返回唯一的值。</p><p>   同样的，SQL子查询都可以使用其他语句达到同样的效果，上面的语句和如下语句达到同样的效果：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; select productName ,count(*) as total from t_product p,t_order o where p.id = o.productId group by productName;</div><div class="line">&gt;</div><div class="line">&gt; select productName ,count(*) as total from t_product p join t_order o on p.id = o.productId group by productName;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p>   子查询作为计算列且作为无关子查询时使用，只会一次性返回但一值，这里就不再阐述了。</p></blockquote><h3 id="子查询案例"><a href="#子查询案例" class="headerlink" title="子查询案例"></a>子查询案例</h3><blockquote></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.1 Retrieve cids of customers who place orders with agents in Duluth or Dallas</div><div class="line"></div><div class="line">SQL 1</div><div class="line"><span class="keyword">select</span>  <span class="keyword">distinct</span>  cid</div><div class="line"><span class="keyword">from</span>    orders  o, agents  a</div><div class="line"><span class="keyword">where</span>  a.aid=o.aid  <span class="keyword">and</span></div><div class="line">    (a.city=‘Duluth’ <span class="keyword">or</span> a.city=‘Dallas’);</div><div class="line">SQL 2 (FAST   Why?)</div><div class="line"><span class="keyword">select</span>   <span class="keyword">distinct</span>  cid</div><div class="line"><span class="keyword">from</span>     orders</div><div class="line"><span class="keyword">where</span>   aid  <span class="keyword">IN</span>  (</div><div class="line"><span class="keyword">select</span>  aid         <span class="comment">--uncorrelated Subquery:(a05,a06)非相关的子查询，更快</span></div><div class="line"><span class="keyword">from</span>  agents</div><div class="line"><span class="keyword">where</span>  city= ‘Duluth’  <span class="keyword">or</span>  city=‘Dallas’)</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.2 Get all information concerning agents based in Duluth or Dallas.</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>  agents</div><div class="line"><span class="keyword">WHERE</span>  city  <span class="keyword">IN</span>  ( ‘Duluth’, ‘Dallas’ ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.3 Get the names and discounts of all customers who place orders through agents in Duluth or Dallas.</div><div class="line"><span class="keyword">SELECT</span>  cname,  discnt <span class="keyword">FROM</span>      customers</div><div class="line"><span class="keyword">WHERE</span>  cid  <span class="keyword">IN</span>  (</div><div class="line"><span class="keyword">SELECT</span>  o.cid</div><div class="line"><span class="keyword">FROM</span>      orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.aid  <span class="keyword">IN</span>  (</div><div class="line"><span class="keyword">SELECT</span>  a.aid</div><div class="line"><span class="keyword">FROM</span>      agents  a</div><div class="line"><span class="keyword">WHERE</span>  a.city <span class="keyword">IN</span> (‘Duluth’, ‘Dallas’))) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.4 Find the names of customers who order product p05. (<span class="keyword">use</span> uncorrelated Subquery?)相关的子查询</div><div class="line"><span class="keyword">SQL</span>(<span class="number">1</span>)</div><div class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname <span class="keyword">FROM</span>   customers  c,  orders  o <span class="keyword">WHERE</span>  c.cid=o.cid <span class="keyword">and</span> o.pid=‘p05’ ; </div><div class="line"></div><div class="line">SQL(2)</div><div class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname <span class="keyword">FROM</span>   customers  c</div><div class="line"><span class="keyword">WHERE</span> ‘p05’  <span class="keyword">IN</span>  ( <span class="keyword">select</span> pid    <span class="comment">--correlated Subquery 相关的子查询</span></div><div class="line"><span class="keyword">from</span>  orders  o</div><div class="line"><span class="keyword">where</span> o.cid=c.cid );</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.6 Find ordno values for all orders placed by customers in Duluth through agents in New York.</div><div class="line"><span class="keyword">SELECT</span>  ordno</div><div class="line"><span class="keyword">FROM</span>  orders</div><div class="line"><span class="keyword">WHERE</span>  (cid, aid)  <span class="keyword">IN</span></div><div class="line">(<span class="keyword">select</span>  cid, aid</div><div class="line"> <span class="keyword">from</span>      customers  c,  agents  a</div><div class="line"><span class="keyword">where</span>   c.city=‘Duluth’ <span class="keyword">and</span> a.city=‘<span class="keyword">New</span> York’) ; </div><div class="line">//这是两个表的笛卡儿积，先查询c表符合的条件，再查询a表符合的条件，做笛卡尔的乘积，让子查询作为选择条件。</div><div class="line"><span class="keyword">select</span> p.id,o.id <span class="keyword">from</span> t_product p ,t_order o;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.7  Find aid values of agents with a minimum percent commission(佣金).</div><div class="line"><span class="keyword">SELECT</span>  aid</div><div class="line"><span class="keyword">FROM</span>  agents</div><div class="line"><span class="keyword">WHERE</span>  <span class="keyword">percent</span> &lt;= ALL (</div><div class="line"><span class="keyword">SELECT</span> <span class="keyword">percent</span> </div><div class="line">         <span class="keyword">FROM</span> agents</div><div class="line">         ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//找到所有与达拉斯或波士顿的客户相同的折扣客户</div><div class="line">Exp 4.4.8  Find all customers who have the same discount as that of any of the customers in Dallas or Boston.</div><div class="line"><span class="keyword">SELECT</span>  cid,  cname</div><div class="line"><span class="keyword">FROM</span>   customers</div><div class="line"><span class="keyword">WHERE</span>  discnt = <span class="keyword">SOME</span> (</div><div class="line"><span class="keyword">select</span>  discnt</div><div class="line"><span class="keyword">from</span>   customers</div><div class="line"><span class="keyword">where</span>  city=‘Dallas’  <span class="keyword">or</span>  city=‘Boston’ ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Exp 4.4.9 Find cid values of customers with discnt smaller than those of any customers who live in Duluth.</div><div class="line"><span class="keyword">SELECT</span>  cid</div><div class="line"><span class="keyword">FROM</span>      customers</div><div class="line"><span class="keyword">WHERE</span>   discnt  &lt; ALL (</div><div class="line"><span class="keyword">SELECT</span>  discnt</div><div class="line"><span class="keyword">FROM</span>      customers</div><div class="line"><span class="keyword">WHERE</span>   city = ‘Duluth’ ) ;</div><div class="line"><span class="keyword">SELECT</span>  cid</div><div class="line"><span class="keyword">FROM</span>      customers  c1</div><div class="line"><span class="keyword">WHERE</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>    customers  c2</div><div class="line"><span class="keyword">WHERE</span>   c2.city = ‘Duluth’  <span class="keyword">and</span>      </div><div class="line">                           c1.discnt &gt;= c2. discnt  ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Retrieve all customer names where the customer places an order through agent a05.</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname <span class="keyword">FROM</span>      customers c, orders o <span class="keyword">WHERE</span>   c.cid = o.cid  <span class="keyword">and</span>  o.aid = ‘a05’ ;</div><div class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname</div><div class="line"><span class="keyword">FROM</span>      customers</div><div class="line"><span class="keyword">WHERE</span>   cid   <span class="keyword">IN</span>  ( <span class="keyword">SELECT</span>   cid</div><div class="line"><span class="keyword">FROM</span>  orders</div><div class="line"><span class="keyword">WHERE</span>   aid = ‘a05’   ) ;</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span>  <span class="keyword">distinct</span>  cname</div><div class="line"><span class="keyword">FROM</span>      customers  c</div><div class="line"><span class="keyword">WHERE</span>   <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>     orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.cid=c.cid  <span class="keyword">and</span>  o.aid=‘a05’ ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Find all customer names where the customer does not place an order through agent a05.</div><div class="line">((C[cid] – (O where aid = ‘a05’) [cid])  C) [cname]</div><div class="line"><span class="keyword">SELECT</span>  cname<span class="keyword">FROM</span>  customers</div><div class="line"><span class="keyword">WHERE</span>   cid                     (</div><div class="line"><span class="keyword">SELECT</span>  o.cid    <span class="keyword">FROM</span>  orders  o    <span class="keyword">WHERE</span>  o.aid = ‘a05’ ) ;</div><div class="line"><span class="keyword">SELECT</span>  cname<span class="keyword">FROM</span>      customers  c</div><div class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *   <span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>   o.cid = c.cid  <span class="keyword">and</span>  o.aid = ‘a05’  ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[Example] Find all cid, aid pairs where the customer does not place an order through the agent.</div><div class="line"><span class="keyword">SELECT</span>  cid,  aid</div><div class="line"><span class="keyword">FROM</span>  customers  c,  agents  a</div><div class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.cid = c.cid  <span class="keyword">and</span>  o.aid = a.aid );</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span>  cid</div><div class="line"><span class="keyword">FROM</span>      customers  c</div><div class="line"><span class="keyword">WHERE</span>   <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>   o.cid = c.cid  <span class="keyword">and</span>  o.aid = ‘a03’  ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Exp 2.9.4: Find products that have never been ordered by a customer based in New York through an agent based in Boston.</div><div class="line">T1 := (C where city = ‘New York’)[cid]</div><div class="line">T2 := (((T1  O)  A) where city = ‘Boston’) [pid]</div><div class="line">T3 := P[pid] – T2</div><div class="line">SQL:</div><div class="line"><span class="keyword">SELECT</span>  p.pid</div><div class="line"><span class="keyword">FROM</span>    products  p</div><div class="line"><span class="keyword">WHERE</span>  p.pid  <span class="keyword">NOT</span> <span class="keyword">IN</span> (</div><div class="line"><span class="keyword">SELECT</span> o.pid <span class="keyword">FROM</span>  customers c, agents a, orders o <span class="keyword">WHERE</span>  c.city=‘<span class="keyword">New</span> York’  <span class="keyword">and</span></div><div class="line">a.city=‘Boston’  <span class="keyword">and</span>  c.cid=o.cid <span class="keyword">and</span>  o.aid=a.aid ) ;</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[Exp 2.9.11] List pids of products that are ordered through agents who place orders for (possibly different) customers who order at least one product from an agent who has placed an order for customer c001.</div></pre></td></tr></table></figure><h2 id="除法运算的理解"><a href="#除法运算的理解" class="headerlink" title="除法运算的理解"></a>除法运算的理解</h2><h3 id="除法运算的定义"><a href="#除法运算的定义" class="headerlink" title="除法运算的定义"></a>除法运算的定义</h3><blockquote><p>投影运算的含义简单点就是：从表中选择需要的属性列。</p><p>给定关系R(X,Y)和S(Y,Z),其中X,Y,Z为属性组。R中Y与S中的Y可以有不同的属性名,但必须出自相同的域集。R与S的除运算可以得到一个新的关系P(X),P是R中满足下列条件的元组在X 属性列上的投影: 元组在X上的分量值x的像集Y(x)包含S在Y上的投影的集合。<br>求解步骤过程：<br>第一步：找出关系R和关系S中相同的属性，即Y属性。在关系S中对Y做投影（即将Y列取出）；<br>第二步：被除关系R中与S中不相同的属性列是X，关系R在属性X上做取消重复值的投影；<br>第三步：求关系R中X属性对应的像集Y；<br>第四步：判断包含关系，R÷S其实就是判断关系R中X各个值的像集Y是否包含关系S中属性Y的所有值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&gt; 列是属性,行是元组..</div><div class="line">&gt; 而且作投影之后可能会出现重复项,比如:</div><div class="line">&gt;  A B C  </div><div class="line">&gt; a1 b1 c1  </div><div class="line">&gt; a1 b2 c2  </div><div class="line">&gt; a2 b2 c3  </div><div class="line">&gt; 作A的投影就是a1, a2;  减少了一行</div><div class="line">&gt; 总结: </div><div class="line">&gt; 并:属性不变,元组可能增加(集合相等时不增加) </div><div class="line">&gt; 交:属性不变,元组可能减少(集合相等时不减少) </div><div class="line">&gt; 投影:属性可能减少(全投影时不减少),元组可能减少(投影后无重复项时不减少) </div><div class="line">&gt; 笛卡尔积:属性增加,元组可能增加(只有1个元组时不增加)</div><div class="line">&gt; 除运算：</div><div class="line">&gt;</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; 除运算：</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><p>&gt;</p><blockquote><p><strong>R：</strong></p><table><thead><tr><th>A</th><th>B</th><th>C</th></tr></thead><tbody><tr><td>a1</td><td>b1</td><td>c2</td></tr><tr><td>a2</td><td>b3</td><td>c7</td></tr><tr><td>a3</td><td>b4</td><td>c6</td></tr><tr><td>a1</td><td>b2</td><td>c3</td></tr><tr><td>a4</td><td>b6</td><td>c6</td></tr><tr><td>a2</td><td>b2</td><td>c3</td></tr><tr><td>a1</td><td>b2</td><td>c1</td></tr></tbody></table><p><strong>S:</strong></p><table><thead><tr><th>B</th><th>C</th><th>D</th></tr></thead><tbody><tr><td>b1</td><td>c2</td><td>d1</td></tr><tr><td>b2</td><td>c1</td><td>d1</td></tr><tr><td>b2</td><td>c3</td><td>d2</td></tr></tbody></table><p>R÷S</p><table><thead><tr><th>A</th></tr></thead><tbody><tr><td>a1</td></tr></tbody></table><p>(1) 找S与R的共同属性，其元组看做整体 k<br>(2)选择R中包含k的 非S与R相同属性的 属性 即为R÷S<br>*/<br>解答如下：<br>在关系R中，A可以取四个值{a1,a2,a3,a4}，其中：<br>a1的象集为：{（b1,c2），（b2,c3），（b2,c1）}就是a1 对应bc属性上的值<br>a2的象集为：{（b3,c7），（b2,c3）}<br>a3的象集为：{（b4,c6）}<br>a4的象集为：{（b6,c6）}<br>S在（B,C）上的投影为{(b1,c2),(b2,c3),(b2,c1)}。，只取BC两列<br>显然只有a1的象集（B,C）a1包含S在（B,C）属性组上的投影，全部包含，所以R÷S={a1}</p></blockquote><h3 id="SQL中除法运算的实现"><a href="#SQL中除法运算的实现" class="headerlink" title="SQL中除法运算的实现"></a>SQL中除法运算的实现</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">SQL中除法运算的实现</div><div class="line">R(X，Y)÷S(Y，Z)的运算用结构化语言SQL 语句可表达为下列形式:</div><div class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R.X <span class="keyword">from</span> R R1</div><div class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></div><div class="line">( <span class="keyword">select</span> S.Y <span class="keyword">from</span> S</div><div class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></div><div class="line">( <span class="keyword">select</span> * <span class="keyword">from</span> R R2</div><div class="line"><span class="keyword">where</span> R2.X=R1.X <span class="keyword">and</span> R2.Y=S.Y ) )</div><div class="line"></div><div class="line">同理, 基于多属性关系除法的<span class="keyword">SQL</span> 表达形式</div><div class="line"><span class="keyword">select</span> <span class="keyword">distinct</span> R1.X1, R1.X2, ⋯, R1.Xn</div><div class="line"><span class="keyword">from</span> R R1</div><div class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></div><div class="line">( <span class="keyword">select</span> S.Y1, S.Y2, ⋯, S.Ym <span class="keyword">from</span> S</div><div class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span></div><div class="line">( <span class="keyword">select</span> * <span class="keyword">from</span> R R2</div><div class="line"><span class="keyword">where</span> R2.X1=R1.X1 <span class="keyword">and</span> R2.X2=R1.X2 <span class="keyword">and</span>……<span class="keyword">and</span> R2.Xn=R1.Xn <span class="keyword">and</span></div><div class="line">R2.Y1=S.Y1 <span class="keyword">and</span> R2.Y2=S.Y2 <span class="keyword">and</span>……<span class="keyword">and</span> R2.Ym=S.Ym) )</div></pre></td></tr></table></figure><h3 id="除法运算的案例"><a href="#除法运算的案例" class="headerlink" title="除法运算的案例"></a>除法运算的案例</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">The division operation in Relational Algebra</div><div class="line"></div><div class="line">[Example 4.5.2] Find cids of customers who place orders with ALL agents based in New York.</div><div class="line">o[cid, aid]  (a where city=‘New York’)[aid]</div><div class="line"></div><div class="line"><span class="keyword">SELECT</span>  c.cid    <span class="keyword">FROM</span>    customers  c</div><div class="line"><span class="keyword">WHERE</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *  <span class="keyword">FROM</span>  agents  a</div><div class="line"><span class="keyword">WHERE</span>  a.city = ‘<span class="keyword">New</span> York’  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *  <span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.cid = c.cid  <span class="keyword">and</span>  o.aid = a.aid ) )</div></pre></td></tr></table></figure><blockquote><p>ALL是除法运算的一个关键词</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Exp 4.5.3: Get the aid values of agents in New York or Duluth who place orders for all products costing more than a dollar.</div><div class="line"><span class="keyword">SELECT</span>  aid</div><div class="line"><span class="keyword">FROM</span>    agents  a</div><div class="line"><span class="keyword">WHERE</span>  (city=‘<span class="keyword">New</span> York’ <span class="keyword">or</span> city=‘Duluth’) <span class="keyword">and</span></div><div class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>  products  p</div><div class="line"><span class="keyword">WHERE</span>  p.price &gt; <span class="number">1</span>  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *</div><div class="line"><span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.aid=a.aid <span class="keyword">and</span> o.pid=p.pid))；</div></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exp 4.5.4: Find aid values of agents who place orders for product p01 as well as for all products costing more than a dollar.</div><div class="line"><span class="keyword">SELECT</span>  aid    <span class="keyword">FROM</span>  agents  a</div><div class="line"><span class="keyword">WHERE</span>   aid <span class="keyword">IN</span> (  <span class="keyword">select</span> aid <span class="keyword">from</span> orders</div><div class="line">    <span class="keyword">where</span> pid=‘p01’ )</div><div class="line"><span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *    <span class="keyword">FROM</span>  products  p</div><div class="line"><span class="keyword">WHERE</span>  p.price &gt; <span class="number">1</span>  <span class="keyword">and</span>  <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</div><div class="line"><span class="keyword">SELECT</span>  *    <span class="keyword">FROM</span>  orders  o</div><div class="line"><span class="keyword">WHERE</span>  o.aid=a.aid <span class="keyword">and</span> o.pid=p.pid))</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Exp 4.5.5: Find cids for customers who order all products ordered by customer c006.</div><div class="line">      ORDERS [ cid, pid ]  除以 ( ORDERS where cid = ‘c006’ ) [ pid ]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    本文内容记载在我在学习数据库这门课程中的知识点，内容涵盖对sql关键字的讲解，sql语句的具体案例及分析。&lt;/p&gt;
    
    </summary>
    
      <category term="database" scheme="https://shangrila-kun.github.io/categories/database/"/>
    
    
      <category term="sql" scheme="https://shangrila-kun.github.io/tags/sql/"/>
    
  </entry>
  
  <entry>
    <title>js读取本地文件</title>
    <link href="https://shangrila-kun.github.io/2017/10/29/jsreadxml/"/>
    <id>https://shangrila-kun.github.io/2017/10/29/jsreadxml/</id>
    <published>2017-10-29T01:22:53.000Z</published>
    <updated>2017-10-29T02:10:36.612Z</updated>
    
    <content type="html"><![CDATA[<p>​    以前，在写页面的时候，都采取了硬编码，这次接到一个需求，做一个展示界面，用来展示各个项目，并提供入口，需求是展示界面的项目内容主要展示的是:已上线项目、待上线项目、内网项目，由于项目的划分多变，所以，最好是能够通过配置来展示页面的内容，就考虑了js读取本地xml。</p><a id="more"></a><h1 id="js读取xml"><a href="#js读取xml" class="headerlink" title="js读取xml"></a>js读取xml</h1><p>代码内容如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">autoLoadConf</span>(<span class="params"></span>) </span>&#123;</div><div class="line">   </div><div class="line">       <span class="comment">/*读取配置文件*/</span></div><div class="line">       </div><div class="line">       $.ajax(&#123;</div><div class="line">                    <span class="attr">url</span>: <span class="string">"../nav/conf/links.xml"</span>,</div><div class="line">                    <span class="attr">dataType</span>: <span class="string">'xml'</span>,</div><div class="line">                    <span class="attr">type</span>: <span class="string">'GET'</span>,</div><div class="line">                    <span class="attr">timeout</span>: <span class="number">2000</span>,</div><div class="line">                    <span class="attr">error</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xml</span>)</span></div><div class="line">                    &#123;</div><div class="line">                        alert(<span class="string">"读取配置文件失败！"</span>);</div><div class="line">                    &#125;,</div><div class="line">                    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">xml</span>)</span></div><div class="line">                    &#123;</div><div class="line"></div><div class="line">                        <span class="keyword">var</span> jqueryObject = $(xml);<span class="comment">//把读取的xum对象转换为jquery对象</span></div><div class="line">                        <span class="comment">/*已上线项目*/</span></div><div class="line">                        <span class="keyword">var</span> onlineArray = readXml(jqueryObject,<span class="string">"websites"</span>,<span class="string">"online_websites"</span>,<span class="string">"online_website"</span>);</div><div class="line">                        addLiContent($(<span class="string">"#onlineLinkUl"</span>),onlineArray);</div><div class="line">                        <span class="comment">/*待上线项目*/</span></div><div class="line">                        <span class="keyword">var</span> weiArray = readXml(jqueryObject,<span class="string">"websites"</span>,<span class="string">"wei_websites"</span>,<span class="string">"wei_website"</span>);</div><div class="line">                        addLiContent($(<span class="string">"#weiLinkUl"</span>),weiArray);</div><div class="line">                        <span class="comment">/*内网正式项目项目*/</span></div><div class="line">                        <span class="keyword">var</span> neiArray = readXml(jqueryObject,<span class="string">"websites"</span>,<span class="string">"nei_websites"</span>,<span class="string">"nei_website"</span>);</div><div class="line">                        addLiContent($(<span class="string">"#neiLinkUl"</span>),neiArray);</div><div class="line"></div><div class="line">              </div><div class="line">                    &#125;  </div><div class="line"></div><div class="line">                &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readXml</span>(<span class="params">jqueryObject,f1,f2,f3</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> arrayObject = <span class="keyword">new</span> <span class="built_in">Array</span>();</div><div class="line">    jqueryObject.find(f1).find(f2).find(f3).each(<span class="function"><span class="keyword">function</span>(<span class="params">i</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> online = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">    online.title = $(<span class="keyword">this</span>).find(<span class="string">"title"</span>).text();</div><div class="line">    online.link = $(<span class="keyword">this</span>).find(<span class="string">"link"</span>).text();</div><div class="line">    arrayObject.push(online);</div><div class="line">  &#125;);</div><div class="line">  <span class="built_in">console</span>.log(arrayObject);</div><div class="line">  <span class="keyword">return</span> arrayObject;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*给指定的ul添加li的内容*/</span></div><div class="line"><span class="comment">/*备注：class='item s"+((i+1)%9+1)+"' ((i+1)%9+1)此代码的写法是经过测试发现，css样式只有是s1到s9类。  */</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addLiContent</span>(<span class="params">ulObject,arrayObject</span>)</span>&#123;<span class="comment">//参数一，获取指定ul的对象，参数二，获取读xml遍历出来的数组</span></div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i&lt;arrayObject.length;i++)&#123;</div><div class="line">        <span class="keyword">var</span> hrefValue = arrayObject[i].link;</div><div class="line">        <span class="keyword">var</span> titleValue = arrayObject[i].title;</div><div class="line">        <span class="keyword">var</span> liHtml=<span class="string">"&lt;li class='item s"</span>+((i+<span class="number">1</span>)%<span class="number">9</span>+<span class="number">1</span>)+<span class="string">"' id=\"btn-in1\"&gt;"</span>+</div><div class="line">          <span class="string">"&lt;a href='"</span>+hrefValue+<span class="string">"'  target='_blank'&gt;"</span>+</div><div class="line">            <span class="string">"&lt;p class=\"pic\"&gt;&lt;span class=\"fa fa-database fa-5x\"&gt;&lt;/span&gt;&lt;/p&gt;"</span>+</div><div class="line">            <span class="string">"&lt;p class=\"name\"&gt;"</span>+titleValue+<span class="string">"&lt;/p&gt;&lt;p&gt;&lt;button class='btn-in in1' style=\"color: rgb(255, 255, 255); background: transparent;\"&gt;进入&lt;/button&gt;&lt;/p&gt;"</span>+</div><div class="line">        <span class="string">"&lt;/a&gt;&lt;/li&gt;"</span>;</div><div class="line">        ulObject.append(liHtml);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    以前，在写页面的时候，都采取了硬编码，这次接到一个需求，做一个展示界面，用来展示各个项目，并提供入口，需求是展示界面的项目内容主要展示的是:已上线项目、待上线项目、内网项目，由于项目的划分多变，所以，最好是能够通过配置来展示页面的内容，就考虑了js读取本地xml。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="https://shangrila-kun.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="js" scheme="https://shangrila-kun.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>linux安装软件教程</title>
    <link href="https://shangrila-kun.github.io/2017/10/13/linux20171013/"/>
    <id>https://shangrila-kun.github.io/2017/10/13/linux20171013/</id>
    <published>2017-10-13T07:10:29.000Z</published>
    <updated>2017-10-13T07:18:41.306Z</updated>
    
    <content type="html"><![CDATA[<p>​    每次想着安装linux上面的软件，有时候要去网上查资料，有时候测试之后才发现网上的有些资料的正确与否，或者是否过时，这个是我们目前所用到的教程，并经过自己实践后，整理如下：</p><a id="more"></a><h1 id="linux安装软件教程"><a href="#linux安装软件教程" class="headerlink" title="linux安装软件教程"></a>linux安装软件教程</h1><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><p>​    安装连接   <a href="http://www.linuxidc.com/Linux/2016-09/134941.htm" target="_blank" rel="noopener">点击即可</a></p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><p>​    安装链接  <a href="http://www.linuxidc.com/Linux/2016-09/134907.htm" target="_blank" rel="noopener">点击即可</a></p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&gt; 根据端口列进程</div><div class="line">&gt; netstat -ntlp | grep 80 </div><div class="line">&gt; kill -INT 进程号  杀某一进程</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote><h3 id="Nginx下信号量"><a href="#Nginx下信号量" class="headerlink" title="Nginx下信号量"></a>Nginx下信号量</h3><blockquote><p>kill -INT 进程号  简单粗暴的杀死进程</p><p>kill -quit 优雅的杀死进程，等请求结束后，再关闭</p><p>kill -HUB 进程号   改变配置文件，平滑的重读配置文件</p><p>kill -HUN ‘cat logs/nginx.pid’优雅的更新配置</p></blockquote><h3 id="Nginx下的日志"><a href="#Nginx下的日志" class="headerlink" title="Nginx下的日志"></a>Nginx下的日志</h3><blockquote><p><a href="http://www.cnblogs.com/crazylqy/p/6891991.html" target="_blank" rel="noopener">nginx下日志管理</a></p><p><a href="http://www.cnblogs.com/mfryf/p/3336804.html" target="_blank" rel="noopener">tail命令</a></p><p><a href="http://www.cnblogs.com/ilanni/p/5365420.html" target="_blank" rel="noopener">nginx日志切割管理</a> </p></blockquote><h3 id="Ngnix下面的location匹配规则"><a href="#Ngnix下面的location匹配规则" class="headerlink" title="Ngnix下面的location匹配规则"></a>Ngnix下面的location匹配规则</h3><p><img src="http://upload-images.jianshu.io/upload_images/7882280-01cecbe1d8f921e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="123.png"></p><p><img src="http://upload-images.jianshu.io/upload_images/7882280-731500b26046ea06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="456.png"></p><blockquote><p><a href="http://blog.csdn.net/qq_39781497/article/details/78038959" target="_blank" rel="noopener">nginx配置location总结</a>  </p></blockquote><h3 id="Nginx的rewrite重写"><a href="#Nginx的rewrite重写" class="headerlink" title="Nginx的rewrite重写"></a>Nginx的rewrite重写</h3><blockquote><p><a href="http://www.linuxidc.com/Linux/2014-01/95493.htm" target="_blank" rel="noopener">rewire重写</a> </p><p><a href="http://www.linuxidc.com/Linux/2014-01/95493.htm" target="_blank" rel="noopener">rewrite重写规则</a> </p></blockquote><h2 id="Mysql安装"><a href="#Mysql安装" class="headerlink" title="Mysql安装"></a>Mysql安装</h2><blockquote><p><a href="http://blog.csdn.net/hellozhijian/article/details/78067593" target="_blank" rel="noopener">mysql安装</a> </p></blockquote><h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><blockquote><p><a href="http://blog.csdn.net/default7/article/details/54925702" target="_blank" rel="noopener">tomcat的安装</a> </p></blockquote><h2 id="Mongodb3-4安装"><a href="#Mongodb3-4安装" class="headerlink" title="Mongodb3.4安装"></a>Mongodb3.4安装</h2><blockquote><p><a href="http://www.cnblogs.com/acewhl/p/6638486.html" target="_blank" rel="noopener">mongodb3.4安装</a> </p></blockquote><h2 id="查看系统版本信息"><a href="#查看系统版本信息" class="headerlink" title="查看系统版本信息"></a>查看系统版本信息</h2><blockquote><p><a href="http://www.linuxidc.com/Linux/2014-12/110748.htm" target="_blank" rel="noopener">如何查看已安装的CentOS版本信息</a></p><p>lsb_release 是查看系统版本信息的工具,如果出现-bash: lsb_release: command not found,解决方法：yum install redhat-lsb -y</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt; [root@localhost ~]# lsb_release  -a</div><div class="line">&gt; LSB Version:    :core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0- noarch:printing-4.0-amd64:printing-4.0-noarch</div><div class="line">&gt; Distributor ID: CentOS</div><div class="line">&gt; Description:    CentOS Linux release 6.0 (Final)</div><div class="line">&gt; Release:        6.0</div><div class="line">&gt; Codename:       Final</div><div class="line">&gt;</div></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    每次想着安装linux上面的软件，有时候要去网上查资料，有时候测试之后才发现网上的有些资料的正确与否，或者是否过时，这个是我们目前所用到的教程，并经过自己实践后，整理如下：&lt;/p&gt;
    
    </summary>
    
      <category term="linux" scheme="https://shangrila-kun.github.io/categories/linux/"/>
    
    
      <category term="软件安装" scheme="https://shangrila-kun.github.io/tags/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Hexo在多台电脑上提交和更新github pages博客</title>
    <link href="https://shangrila-kun.github.io/2017/09/10/hexo20170917/"/>
    <id>https://shangrila-kun.github.io/2017/09/10/hexo20170917/</id>
    <published>2017-09-10T01:10:29.000Z</published>
    <updated>2017-09-10T07:33:31.992Z</updated>
    
    <content type="html"><![CDATA[<p>​    在实验室电脑上用hexo搭建博客，但是，每次发博客的时候只能用实验室电脑发。于是想在宿舍电脑上也搭建一个，来协同工作。</p><a id="more"></a><p>​    由于实验室的小伙伴已经写了一份操作文档，我就直接粘贴链接过来。<a href="https://michaeljian.github.io/2017/09/07/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8Hexo%E5%9C%A8%E5%A4%9A%E5%8F%B0%E7%94%B5%E8%84%91%E4%B8%8A%E6%8F%90%E4%BA%A4%E5%92%8C%E6%9B%B4%E6%96%B0github-pages%E5%8D%9A%E5%AE%A2/" target="_blank" rel="noopener">点击即可查看</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    在实验室电脑上用hexo搭建博客，但是，每次发博客的时候只能用实验室电脑发。于是想在宿舍电脑上也搭建一个，来协同工作。&lt;/p&gt;
    
    </summary>
    
      <category term="hexo系列干货" scheme="https://shangrila-kun.github.io/categories/hexo%E7%B3%BB%E5%88%97%E5%B9%B2%E8%B4%A7/"/>
    
    
      <category term="多电脑操作githubblog" scheme="https://shangrila-kun.github.io/tags/%E5%A4%9A%E7%94%B5%E8%84%91%E6%93%8D%E4%BD%9Cgithubblog/"/>
    
  </entry>
  
  <entry>
    <title>添加Fork me on GitHub 小丝带</title>
    <link href="https://shangrila-kun.github.io/2017/08/30/0830githugfork/"/>
    <id>https://shangrila-kun.github.io/2017/08/30/0830githugfork/</id>
    <published>2017-08-30T11:27:28.000Z</published>
    <updated>2017-08-31T03:12:36.934Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在自己的博客上面挂一个Fork me on GitHub简直是一个装逼神器，更能体现出一个程序员的气质，经过从网上查找，将查找内容整理如下：</strong></p><a id="more"></a><h2 id="添加Fork-me-on-GitHub-小丝带"><a href="#添加Fork-me-on-GitHub-小丝带" class="headerlink" title="添加Fork me on GitHub 小丝带"></a>添加Fork me on GitHub 小丝带</h2><h3 id="操作过程"><a href="#操作过程" class="headerlink" title="操作过程"></a>操作过程</h3><h4 id="第一步-创建一个ribbon-ejs"><a href="#第一步-创建一个ribbon-ejs" class="headerlink" title="第一步  创建一个ribbon.ejs"></a>第一步  创建一个ribbon.ejs</h4><p>​    <strong>在主题目录下的/layout/_partial下面创建一个ribbon.ejs，输入下面的代码进去</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"ribbon"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://github.com/your username"</span>&gt;</span>Fork me on GitHub<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="第二步-添加代码到after-footer-ejs"><a href="#第二步-添加代码到after-footer-ejs" class="headerlink" title="第二步  添加代码到after_footer.ejs"></a>第二步  添加代码到after_footer.ejs</h4><p>​    <strong>接着要在/layout/_partial/after_footer.ejs中加入一行</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;%- partial(<span class="string">'ribbon'</span>) %&gt;</div><div class="line">  <span class="comment">//此代码的作用是确保这个div能在页面上显示出来。</span></div></pre></td></tr></table></figure><h4 id="第三步-创建ribbon-styl"><a href="#第三步-创建ribbon-styl" class="headerlink" title="第三步  创建ribbon.styl"></a>第三步  创建ribbon.styl</h4><p>​    <strong>添加css,hexo可以在主题目录的/source/css/_partial下创建一个ribbon.styl，然后把下面的代码复制进去。</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.ribbon</span> &#123;</div><div class="line">  <span class="attribute">background-color</span>: <span class="number">#a00</span>;</div><div class="line">  <span class="attribute">overflow</span>: hidden;</div><div class="line">  <span class="attribute">white-space</span>: nowrap;</div><div class="line">  <span class="comment">/* top right corner */</span></div><div class="line">  <span class="attribute">position</span>: fixed;</div><div class="line">  <span class="attribute">right</span>: -<span class="number">50px</span>;</div><div class="line">  <span class="attribute">top</span>: <span class="number">40px</span>;</div><div class="line">  <span class="comment">/* 45 deg ccw rotation */</span></div><div class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">     <span class="attribute">-moz-transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">      <span class="attribute">-ms-transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">       <span class="attribute">-o-transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">          <span class="attribute">transform</span>: <span class="built_in">rotate</span>(45deg);</div><div class="line">  <span class="comment">/* shadow */</span></div><div class="line">  <span class="attribute">-webkit-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#888</span>;</div><div class="line">     <span class="attribute">-moz-box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#888</span>;</div><div class="line">          <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> <span class="number">#888</span>;</div><div class="line">&#125;</div><div class="line"><span class="selector-class">.ribbon</span> <span class="selector-tag">a</span> &#123;</div><div class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#faa</span>;</div><div class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</div><div class="line">  <span class="attribute">display</span>: block;</div><div class="line">  <span class="attribute">font</span>: bold <span class="number">81.25%</span> <span class="string">'Helvetica Neue'</span>, Helvetica, Arial, sans-serif;</div><div class="line">  <span class="attribute">margin</span>: <span class="number">1px</span> <span class="number">0</span>;</div><div class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">50px</span>;</div><div class="line">  <span class="attribute">text-align</span>: center;</div><div class="line">  <span class="attribute">text-decoration</span>: none;</div><div class="line">  <span class="comment">/* shadow */</span></div><div class="line">  <span class="attribute">text-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="number">#444</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="第四步-在style-styl中添加内容"><a href="#第四步-在style-styl中添加内容" class="headerlink" title="第四步  在style.styl中添加内容"></a>第四步  在style.styl中添加内容</h4><p>​    <strong>复制一下代码到style.styl（在主题目录下面的\source\css下面）的最后添加一行（针对Hexo博客用户）：</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">if</span> <span class="selector-tag">ribbon</span></div><div class="line">    @<span class="keyword">import</span> <span class="string">'_partial/ribbon'</span></div></pre></td></tr></table></figure><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p>​    <strong>点击 <a href="http://www.haoeasy.cn" target="_blank" rel="noopener">效果图</a>     即可查看。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;在自己的博客上面挂一个Fork me on GitHub简直是一个装逼神器，更能体现出一个程序员的气质，经过从网上查找，将查找内容整理如下：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="hexo干货系列" scheme="https://shangrila-kun.github.io/categories/hexo%E5%B9%B2%E8%B4%A7%E7%B3%BB%E5%88%97/"/>
    
    
      <category term="Fork小丝带" scheme="https://shangrila-kun.github.io/tags/Fork%E5%B0%8F%E4%B8%9D%E5%B8%A6/"/>
    
  </entry>
  
  <entry>
    <title>java访问控制权限</title>
    <link href="https://shangrila-kun.github.io/2017/08/27/20170828java6/"/>
    <id>https://shangrila-kun.github.io/2017/08/27/20170828java6/</id>
    <published>2017-08-27T01:10:29.000Z</published>
    <updated>2017-08-29T13:08:45.905Z</updated>
    
    <content type="html"><![CDATA[<p><strong>1、 java中为什么要设计访问控制权限机制了？</strong></p><p>​    A：为了使用户不要调用他们不应该调用的部分，这些部分对于类内部的操作是必要的，但是它并不是客户端程序员所需接口的一部分。</p><p>​    B：为了让类库设计者可用更改类的内部工作方法，而不必担心会对用户造成重大影响。</p><a id="more"></a><p><strong>2、java中访问权限控制的等级？</strong></p><p>​    Public&gt; Protected &gt; 包访问权限（没有权限修饰词）default &gt; private </p><p><strong>3、包的介绍</strong></p><p>​    Java中包(package)的概念和C++中命名空间(namespace)的概念很类似，都可以限制类的作用域。二者最大的差别在于，Java中的包隐式地指明了类的树形层级结构（同时也是Java源码文件的目录结构）。这样做的好处在于：可以通过文件系统中对于文件路径唯一性的要求来限制类的唯一性。</p><p>​    编写一个Java源代码文件(<strong>.java</strong>文件)时，此文件通常被称为<strong>编译单元</strong>。在编译单元内最多允许有一个<strong>public</strong>类，且该类的名称必须与文件名完全相同（包括大小写）。</p><p>​    编译一个<strong>.java</strong>文件时，在<strong>.java</strong>文件中的每个类都会有一个<strong>.class</strong>输出文件，这个文件名和类名是相同的。Java可运行程序是一组可以打包并压缩为一个Java文档文件(JAR包，使用Java的jar文档生成器)的<strong>.class</strong>文件。Java解释器负责这些文件的查找、装载和解释。</p><p>​    类库实际上是一组类文件。其中每个<strong>.java</strong>文件最多允许有一个<strong>public</strong>类，以及任意数量的非<strong>public</strong>类。因此，每个文件都有一个构件。如果要将这些构件（每个构建有一个<strong>.java</strong>文件和若干个<strong>.class</strong>文件）组织起来，形成不同的群组，可以使用Java中的关键字<strong>package</strong>。</p><p>​    <strong>3.1 包的作用</strong></p><p>​    (1)     把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。</p><p>​    (2)     如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。</p><p>​    (3)     包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。</p><p><strong>4、package：包访问权限</strong></p><p>​    如果不提供任何访问权限修饰词，则意味着它是<strong>包访问权限</strong>。</p><p>​    默认访问权限<strong>没有任何关键字</strong>，但通常是指<strong>包访问权限</strong>（有时也表示为<strong>friendly</strong>，有点像C++中的友元概念）。这意味着包中所有其他类都可以访问这个成员或方法，但是<strong>这个包之外的所有类不可以访问</strong>。</p><p>​    如果一个类、类属变量及方法不以这三种修饰符来修饰，它就是friendly类型的，那么包内的任何类都可以访问它，而包外的任何类都不能访问它(包括包外继承了此类的子类)，因此，这种类、类属变量及方法对包内的其他类是友好的，开放的，而对包外的其他类是关闭的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.notes.packages.test;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Info</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"default method -- print()"</span>); &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>5、public：接口访问权限</strong></p><p>​    使用<strong>public</strong>关键字，就意味着被声明的成员或方法<strong>对所有人都是可以访问的</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"default method -- print()"</span>);</div></pre></td></tr></table></figure><p><strong>6、private ：无法访问</strong></p><p>​    使用<strong>private</strong>关键字，就意味着被声明的成员或方法，<strong>除了本类，其他任何类都无法访问</strong>。</p><p>应用场景：单例模式<a href="http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/" target="_blank" rel="noopener">http://wuchong.me/blog/2014/08/28/how-to-correctly-write-singleton-pattern/</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </div><div class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </div><div class="line">    &#125;  </div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE; </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>7、protected:继承访问权限</strong></p><p>​    新类（称之子类或派生类）通过继承可以复用一个现有类（称之父类或基类），然后扩展基类的成员、方法。有时，基类的创建者会希望某个特定成员，将它的访问权限赋予派生类而不是所有类。<strong>public</strong>无法做到这一点，为此，引入了<strong>protected</strong>来完成这一工作。<strong>protected</strong>也提供包访问权限，也就是说，<strong>派生类以及相同包内的其他类都可以访问</strong>protected成员或方法**。</p><p>例：子类继承父类后，可以访问父类的protected成员。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String a = <span class="string">"private"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> String b = <span class="string">"protected"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> String c = <span class="string">"public"</span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">publicvoid <span class="title">print</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// System.out.println("element a：" + super.a); // Error</span></div><div class="line"></div><div class="line">        System.out.println(<span class="string">"element b："</span> + <span class="keyword">super</span>.b);</div><div class="line"></div><div class="line">        System.out.println(<span class="string">"element c："</span> + <span class="keyword">super</span>.c);</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"> </div><div class="line"></div><div class="line">publicclass ProtectedDemo01 &#123;</div><div class="line"></div><div class="line">    <span class="function">publicstaticvoid <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</div><div class="line"></div><div class="line">        Son sub = <span class="keyword">new</span> Son();</div><div class="line"></div><div class="line">        sub.print();</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;1、 java中为什么要设计访问控制权限机制了？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​    A：为了使用户不要调用他们不应该调用的部分，这些部分对于类内部的操作是必要的，但是它并不是客户端程序员所需接口的一部分。&lt;/p&gt;
&lt;p&gt;​    B：为了让类库设计者可用更改类的内部工作方法，而不必担心会对用户造成重大影响。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="https://shangrila-kun.github.io/categories/Java/"/>
    
    
      <category term="访问控制权限" scheme="https://shangrila-kun.github.io/tags/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/"/>
    
  </entry>
  
  <entry>
    <title>SQL中execute操作返回false的问题</title>
    <link href="https://shangrila-kun.github.io/2017/08/15/20170823sql/"/>
    <id>https://shangrila-kun.github.io/2017/08/15/20170823sql/</id>
    <published>2017-08-15T05:57:36.000Z</published>
    <updated>2017-08-29T13:11:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>​    <strong>今天在码代码的时候遇到了一个问题，代码如下：</strong></p><a id="more"></a><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">SQL一：</div><div class="line">            sql = " <span class="keyword">update</span> t_receive_user <span class="keyword">set</span> user_email = ?, user_name = ?, user_tel = ?, update_timestamp = ? , note = ? <span class="string">" +</span></div><div class="line">                    " <span class="keyword">where</span> user_sid = ? <span class="string">";</span></div><div class="line">            connection = getDataSource().getConnection();</div><div class="line">            ps = connection.prepareStatement(sql);</div><div class="line">            ps.setObject(1,tReceiveUser.getUserEmail());</div><div class="line">            ps.setObject(2,tReceiveUser.getUserName());</div><div class="line">            ps.setObject(3,tReceiveUser.getUserTel());</div><div class="line">            ps.setObject(4,Time.getCurrentTime()/1000);</div><div class="line">            ps.setObject(5,tReceiveUser.getNote());</div><div class="line">            ps.setObject(6,tReceiveUser.getUserSid());</div><div class="line">            System.out.println(ps.execute());</div><div class="line">SQL二：</div><div class="line"> sql = " <span class="keyword">delete</span> t_receive_user <span class="keyword">where</span> user_sid = ? <span class="string">";</span></div><div class="line">            connection = getDataSource().getConnection();</div><div class="line">            ps = connection.prepareStatement(sql);</div><div class="line">            ps.setObject(1,tReceiveUser.getUserSid());</div><div class="line">            System.out.println(ps.execute());</div><div class="line">SQL三：</div><div class="line">sql = "<span class="keyword">INSERT</span> t_receive_user (user_email,user_name,user_tel,update_timestamp,note)<span class="string">" +</span></div><div class="line">                    " <span class="keyword">values</span> (?,?,?,?,?)<span class="string">";</span></div><div class="line">            ps = connection.prepareStatement(sql);</div><div class="line">            ps.setObject(1,tReceiveUser.getUserEmail());</div><div class="line">            ps.setObject(2,tReceiveUser.getUserName());</div><div class="line">            ps.setObject(3,tReceiveUser.getUserTel());</div><div class="line">            ps.setObject(4,Time.getCurrentTime()/1000);</div><div class="line">            ps.setObject(5,tReceiveUser.getNote());</div><div class="line">            System.out.println(ps.execute());</div></pre></td></tr></table></figure><p>​    <strong>我发现即使我的数据库更新成功、删除成功、增加成功，返回值都是false。</strong></p><p><strong>execute内部细节代码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.checkClosed().getConnectionMutex()) &#123;</div><div class="line">            <span class="keyword">boolean</span> returnVal = <span class="keyword">false</span>;</div><div class="line">            <span class="keyword">this</span>.checkStreamability();</div><div class="line">            <span class="keyword">this</span>.setInOutParamsOnServer();</div><div class="line">            <span class="keyword">this</span>.setOutParams();</div><div class="line">            returnVal = <span class="keyword">super</span>.execute();</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.callingStoredFunction) &#123;</div><div class="line">                <span class="keyword">this</span>.functionReturnValueResults = <span class="keyword">this</span>.results;</div><div class="line">                <span class="keyword">this</span>.functionReturnValueResults.next();</div><div class="line">                <span class="keyword">this</span>.results = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">this</span>.retrieveOutParams();</div><div class="line">            <span class="keyword">return</span> !<span class="keyword">this</span>.callingStoredFunction?returnVal:<span class="keyword">false</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><p>​    <strong>查资料发现：boolean execute() throws SQLException在此 PreparedStatement 对象中执行 SQL 语句，该语句可以是任何种类的 SQL 语句。一些特别处理过的语句返回多个结果，execute 方法处理这些复杂的语句；executeQuery 和 executeUpdate 处理形式更简单的语句。 execute 方法返回一个 boolean 值，以指示第一个结果的形式。必须调用 getResultSet 或 getUpdateCount 方法来检索结果，并且必须调用 getMoreResults 移动到任何后面的结果返回：如果第一个结果是 ResultSet 对象，则返回 true；如果第一个结果是更新计数或者没有结果，则返回 false，意思就是如果是查询的话返回true，如果是更新或插入的话就返回false了；execute()返回的是一个boolean值,代表两种不同的操作啊,getResultSet()返回的是结果集,而getUpdateCount()返回的是更新的记数</strong>。</p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;​    &lt;strong&gt;今天在码代码的时候遇到了一个问题，代码如下：&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SQL" scheme="https://shangrila-kun.github.io/categories/SQL/"/>
    
    
      <category term="execute问题" scheme="https://shangrila-kun.github.io/tags/execute%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
</feed>
